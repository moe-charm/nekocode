# 🔧 メソッド検出問題の修正計画
作成日: 2025-07-31
緊急度: 高（責務スコアが機能していない）

## 🐛 問題の詳細分析

### 現在の状況
```
テスト結果: nyamesh-cpp プロジェクト
- 総クラス数: 312
- 総メンバ変数数: 19  
- 総メソッド数: 0  ← これが問題！
- 責務スコア: すべて0
```

### 根本原因
1. **C++の特性**
   - ヘッダー（.h）: クラス定義とメソッド宣言
   - 実装（.cpp）: メソッドの実装
   - 現在のアナライザーはこの分離に対応していない

2. **検出パターンの不足**
   ```cpp
   // 現在検出できていないパターン
   class IFileSystemCore {
   public:
       virtual void initialize() = 0;  // 純粋仮想関数
       virtual bool openFile(const std::string& path);  // 仮想関数
       void updateCache();  // 通常のメソッド宣言
   };
   ```

## 🎯 短期修正案（今すぐ実装可能）

### Step 1: ヘッダーファイルのメソッド宣言検出

**実装場所**: `cpp_pegtl_analyzer.hpp`の`detect_member_variables()`と同じ場所

```cpp
void detect_class_methods(AnalysisResult& result, const std::string& content) {
    // 各クラスに対してメソッドを検出
    for (auto& cls : result.classes) {
        // クラス内のメソッド宣言パターン
        std::regex method_pattern(
            R"(^\s*)"  // 行頭の空白
            R"((?:virtual\s+)?)"  // virtual修飾子（オプション）
            R"((?:static\s+)?)"   // static修飾子（オプション）
            R"((?:inline\s+)?)"   // inline修飾子（オプション）
            R"((?:[\w:]+(?:\s*<[^>]+>)?(?:\s*[&*]+)?\s+)?)"  // 戻り値型（オプション）
            R"((\w+))"  // メソッド名
            R"(\s*\([^)]*\))"  // パラメータリスト
            R"(\s*(?:const\s*)?)"  // const修飾子（オプション）
            R"(\s*(?:override\s*)?)"  // override修飾子（オプション）
            R"(\s*(?:=\s*0\s*)?)"  // 純粋仮想関数（オプション）
            R"(\s*;)"  // セミコロン
        );
    }
}
```

### Step 2: 実装ファイルのメソッド定義検出

```cpp
// ClassName::methodName パターンを検出
std::regex impl_method_pattern(
    R"(^(?:[\w:]+(?:\s*<[^>]+>)?(?:\s*[&*]+)?\s+)?)"  // 戻り値型
    R"((\w+)::(\w+))"  // クラス名::メソッド名
    R"(\s*\([^)]*\))"  // パラメータ
    R"([^;]*\{)"       // 実装開始
);
```

### Step 3: クラスとメソッドの関連付け

```cpp
// セッション全体でクラス名をキーにしたマップを作成
std::unordered_map<std::string, ClassInfo*> class_map;

// 実装ファイルを処理する際に、クラス名でマップを参照
if (std::regex_search(line, match, impl_method_pattern)) {
    std::string class_name = match[1].str();
    std::string method_name = match[2].str();
    
    if (class_map.find(class_name) != class_map.end()) {
        FunctionInfo method;
        method.name = method_name;
        method.start_line = line_number;
        class_map[class_name]->methods.push_back(method);
    }
}
```

## 📝 即座に実装すべき最小限の修正

### 修正1: ヘッダーファイルの基本的なメソッド検出

```cpp
// cpp_pegtl_analyzer.hpp に追加
void detect_header_methods(ClassInfo& cls, const std::string& content, 
                          size_t class_start, size_t class_end) {
    std::istringstream stream(content);
    std::string line;
    size_t line_number = 0;
    
    while (std::getline(stream, line)) {
        line_number++;
        if (line_number < class_start || line_number > class_end) continue;
        
        // 簡易パターン: 関数宣言を検出
        // 行に'('と')'と';'が含まれ、'{'が含まれない
        if (line.find('(') != std::string::npos && 
            line.find(')') != std::string::npos &&
            line.find(';') != std::string::npos &&
            line.find('{') == std::string::npos) {
            
            // メソッド名を抽出（簡易版）
            size_t paren_pos = line.find('(');
            size_t name_end = paren_pos;
            while (name_end > 0 && !std::isspace(line[name_end-1])) {
                name_end--;
            }
            
            size_t name_start = name_end;
            while (name_start > 0 && 
                   (std::isalnum(line[name_start-1]) || 
                    line[name_start-1] == '_')) {
                name_start--;
            }
            
            if (name_end > name_start) {
                std::string method_name = line.substr(name_start, 
                                                     name_end - name_start);
                // コンストラクタ/デストラクタを除外
                if (method_name != cls.name && 
                    method_name != "~" + cls.name) {
                    FunctionInfo method;
                    method.name = method_name;
                    method.start_line = line_number;
                    method.end_line = line_number;
                    cls.methods.push_back(method);
                }
            }
        }
    }
}
```

## 🚀 実装手順

1. **まず最小限の修正**（30分）
   - `detect_member_variables()`の後にメソッド検出を追加
   - ヘッダーファイルの基本的なメソッド宣言のみ検出

2. **テスト**（15分）
   - nyamesh-cppプロジェクトで再実行
   - メソッド数が0から増加することを確認

3. **段階的改善**（後日）
   - より正確なパターンマッチング
   - 実装ファイルとの関連付け
   - コンストラクタ/デストラクタの適切な処理

## 📊 期待される結果

修正前:
```json
{
  "total_methods": 0,
  "responsibility_score": 0
}
```

修正後（期待値）:
```json
{
  "total_methods": 200+,
  "responsibility_score": "変数数 × メソッド数で計算"
}
```

## 🎯 成功基準

1. **メソッド検出率**: 少なくとも50%以上のメソッドを検出
2. **責務スコア**: 0以外の値が計算される
3. **誤検出**: マクロや変数宣言をメソッドと誤認しない

---

この修正により、analyzeコマンドが実用的な責務スコアを提供できるようになり、Claude Codeがリファクタリング対象を科学的に特定できるようになります。