//=============================================================================
// ğŸš€ Memory Transport Interface - nyamesh TransportæŠ½è±¡åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³é©ç”¨
//=============================================================================

#pragma once

#include <string>
#include <vector>
#include <memory>
#include <future>
#include <chrono>
#include <nlohmann/json.hpp>
#include <filesystem>

namespace nekocode {
namespace memory {

//=============================================================================
// ğŸ“Š Memory Entry - Serenaäº’æ›ãƒ¡ãƒ¢ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒª
//=============================================================================

struct MemoryEntry {
    std::string key;                              // ãƒ¡ãƒ¢ãƒªãƒ¼ã‚­ãƒ¼ (ãƒ•ã‚¡ã‚¤ãƒ«å)
    std::string content;                          // ãƒ¡ãƒ¢ãƒªãƒ¼å†…å®¹ (Markdown)
    std::chrono::system_clock::time_point created_at;
    std::chrono::system_clock::time_point updated_at;
    nlohmann::json metadata;                      // è¿½åŠ ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
    
    // NekoCodeæ‹¡å¼µ: è§£æçµæœçµ±åˆ
    struct AnalysisData {
        std::string project_path;
        nlohmann::json ast_results;               // Universal ASTçµæœ
        nlohmann::json performance_stats;         // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ
        nlohmann::json complexity_metrics;        // è¤‡é›‘åº¦æŒ‡æ¨™
    } analysis_data;
    
    MemoryEntry() = default;
    MemoryEntry(const std::string& k, const std::string& c) 
        : key(k), content(c), 
          created_at(std::chrono::system_clock::now()),
          updated_at(std::chrono::system_clock::now()) {}
};

//=============================================================================
// ğŸ” Memory Query - é«˜åº¦ãªæ¤œç´¢ã‚¯ã‚¨ãƒª
//=============================================================================

struct MemoryQuery {
    std::string text_search;                      // ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢
    std::vector<std::string> tags;                // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    std::chrono::system_clock::time_point after; // æ—¥æ™‚ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    std::chrono::system_clock::time_point before;
    
    // NekoCodeæ‹¡å¼µ: ã‚³ãƒ¼ãƒ‰è§£æç‰¹åŒ–æ¤œç´¢
    struct CodeSearchCriteria {
        std::vector<std::string> languages;       // è¨€èªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        std::string function_name_pattern;        // é–¢æ•°åãƒ‘ã‚¿ãƒ¼ãƒ³
        std::string class_name_pattern;           // ã‚¯ãƒ©ã‚¹åãƒ‘ã‚¿ãƒ¼ãƒ³
        int min_complexity = 0;                   // æœ€å°è¤‡é›‘åº¦
        int max_complexity = std::numeric_limits<int>::max();
    } code_criteria;
};

//=============================================================================
// ğŸš€ Memory Transport Interface - nyameshãƒ‘ã‚¿ãƒ¼ãƒ³
//=============================================================================

class MemoryTransport {
public:
    virtual ~MemoryTransport() = default;
    
    // åŸºæœ¬CRUDæ“ä½œ
    virtual std::future<bool> store(const MemoryEntry& entry) = 0;
    virtual std::future<MemoryEntry> load(const std::string& key) = 0;
    virtual std::future<bool> remove(const std::string& key) = 0;
    virtual std::future<std::vector<std::string>> list() = 0;
    
    // é«˜åº¦ãªæ¤œç´¢ãƒ»åˆ†æ
    virtual std::future<std::vector<std::string>> search(const MemoryQuery& query) = 0;
    virtual std::future<nlohmann::json> get_statistics() = 0;
    
    // Transportæƒ…å ±
    virtual std::string get_transport_type() const = 0;
    virtual bool is_available() const = 0;
    virtual std::future<void> initialize() = 0;
    virtual std::future<void> cleanup() = 0;
    
    // NekoCodeç‰¹åŒ–: è‡ªå‹•è§£æçµæœä¿å­˜
    virtual std::future<bool> store_analysis_result(
        const std::string& project_path,
        const nlohmann::json& analysis_result,
        const std::string& memory_name = "") = 0;
};

//=============================================================================
// ğŸ“ FileSystem Transport - ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
//=============================================================================

class FileSystemMemoryTransport : public MemoryTransport {
private:
    std::filesystem::path memory_dir_;
    std::string format_;  // "markdown" or "json"
    
public:
    explicit FileSystemMemoryTransport(
        const std::filesystem::path& memory_dir = ".nekocode_memory",
        const std::string& format = "markdown");
    
    // MemoryTransport interface
    std::future<bool> store(const MemoryEntry& entry) override;
    std::future<MemoryEntry> load(const std::string& key) override;
    std::future<bool> remove(const std::string& key) override;
    std::future<std::vector<std::string>> list() override;
    std::future<std::vector<std::string>> search(const MemoryQuery& query) override;
    std::future<nlohmann::json> get_statistics() override;
    
    std::string get_transport_type() const override { return "FileSystem"; }
    bool is_available() const override;
    std::future<void> initialize() override;
    std::future<void> cleanup() override;
    
    std::future<bool> store_analysis_result(const std::string& project_path,
                                           const nlohmann::json& analysis_result,
                                           const std::string& memory_name = "") override;

private:
    std::filesystem::path get_memory_file_path(const std::string& key) const;
    std::string generate_analysis_memory_name(const std::string& project_path) const;
    std::string format_analysis_as_markdown(const nlohmann::json& analysis_result) const;
};

//=============================================================================
// ğŸ”— P2P Memory Transport - nyamesh P2På…±æœ‰
//=============================================================================

class P2PMemoryTransport : public MemoryTransport {
private:
    std::shared_ptr<FileSystemMemoryTransport> local_transport_;  // ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    // TODO: nyamesh P2På®Ÿè£…ã¨é€£æº
    
public:
    explicit P2PMemoryTransport(const std::filesystem::path& cache_dir = ".nekocode_p2p_cache");
    
    // MemoryTransport interface - P2PçµŒç”±ã§å®Ÿè£…
    std::future<bool> store(const MemoryEntry& entry) override;
    std::future<MemoryEntry> load(const std::string& key) override;
    std::future<bool> remove(const std::string& key) override;
    std::future<std::vector<std::string>> list() override;
    std::future<std::vector<std::string>> search(const MemoryQuery& query) override;
    std::future<nlohmann::json> get_statistics() override;
    
    std::string get_transport_type() const override { return "P2P"; }
    bool is_available() const override;
    std::future<void> initialize() override;
    std::future<void> cleanup() override;
    
    std::future<bool> store_analysis_result(const std::string& project_path,
                                           const nlohmann::json& analysis_result,
                                           const std::string& memory_name = "") override;
    
    // P2Pç‰¹åŒ–æ©Ÿèƒ½
    std::future<bool> sync_with_peers();
    std::future<std::vector<std::string>> discover_shared_memories();
};

//=============================================================================
// ğŸ’¾ SQLite Memory Transport - é«˜é€Ÿæ¤œç´¢ç‰¹åŒ–
//=============================================================================

class SQLiteMemoryTransport : public MemoryTransport {
private:
    std::filesystem::path db_path_;
    // TODO: SQLiteå®Ÿè£…
    
public:
    explicit SQLiteMemoryTransport(const std::filesystem::path& db_path = ".nekocode_memory.db");
    
    // MemoryTransport interface - SQLiteæœ€é©åŒ–å®Ÿè£…
    std::future<bool> store(const MemoryEntry& entry) override;
    std::future<MemoryEntry> load(const std::string& key) override;
    std::future<bool> remove(const std::string& key) override;
    std::future<std::vector<std::string>> list() override;
    std::future<std::vector<std::string>> search(const MemoryQuery& query) override;
    std::future<nlohmann::json> get_statistics() override;
    
    std::string get_transport_type() const override { return "SQLite"; }
    bool is_available() const override;
    std::future<void> initialize() override;
    std::future<void> cleanup() override;
    
    std::future<bool> store_analysis_result(const std::string& project_path,
                                           const nlohmann::json& analysis_result,
                                           const std::string& memory_name = "") override;
    
    // SQLiteç‰¹åŒ–æ©Ÿèƒ½
    std::future<void> create_indexes();
    std::future<void> optimize_database();
    std::future<nlohmann::json> get_query_statistics();
};

//=============================================================================
// ğŸ­ Memory Transport Factory
//=============================================================================

class MemoryTransportFactory {
public:
    enum class TransportType {
        FileSystem,
        SQLite,
        P2P,
        Auto  // è‡ªå‹•é¸æŠ
    };
    
    static std::unique_ptr<MemoryTransport> create(
        TransportType type = TransportType::Auto,
        const nlohmann::json& config = {});
        
    static std::vector<TransportType> get_available_transports();
    static std::string transport_type_to_string(TransportType type);
};

} // namespace memory
} // namespace nekocode

//=============================================================================
// ä½¿ç”¨ä¾‹ - Serenaäº’æ› + NekoCodeç‰¹åŒ–
//=============================================================================

/*
// åŸºæœ¬çš„ãªãƒ¡ãƒ¢ãƒªãƒ¼æ“ä½œ (Serenaäº’æ›)
auto transport = MemoryTransportFactory::create(MemoryTransportFactory::TransportType::FileSystem);
await transport->initialize();

MemoryEntry entry("project_analysis", "# Amazing Project Analysis\n...");
await transport->store(entry);

auto loaded = await transport->load("project_analysis");
auto all_memories = await transport->list();
auto search_results = await transport->search(MemoryQuery{.text_search = "performance"});

// NekoCodeç‰¹åŒ–: è‡ªå‹•è§£æçµæœä¿å­˜
nlohmann::json analysis_result = {
    {"files_analyzed", 47},
    {"functions_found", 127},
    {"complexity_score", 435}
};
await transport->store_analysis_result("/path/to/project", analysis_result, "project_deep_analysis");

// P2På…±æœ‰ (nyameshçµ±åˆ)
auto p2p_transport = MemoryTransportFactory::create(MemoryTransportFactory::TransportType::P2P);
await p2p_transport->sync_with_peers();
auto shared_memories = await p2p_transport->discover_shared_memories();
*/