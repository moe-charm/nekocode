# 🔮 NekoCode analyze機能 - 今後の改善計画
作成日: 2025-07-31
目的: Claude Codeがより効果的にリファクタリング支援できる機能の設計

## 🔍 現状の課題分析

### 1. メソッド検出の問題
**現象**: 多くのクラスでmethods=0となり、責務スコアが常に0になる
**原因**: 
- C++ではヘッダーファイル（.h）にメソッド宣言、実装ファイル（.cpp）に定義が分離
- 現在のアナライザーはファイル単位で動作し、クラスとメソッドの関連付けが不完全
- インターフェースクラスは純粋仮想関数のみで実装を持たない

**解決案**:
```cpp
// 1. メソッド宣言も検出（virtual, override, = 0 などを考慮）
// 2. クラス名::メソッド名() パターンで実装を追跡
// 3. セッション全体でクラスとメソッドを関連付け
```

### 2. 責務分析の精度向上

**現在の責務スコア**: 変数数 × メソッド数（単純すぎる）

**改善案**:
```
新責務スコア = (変数数 × メソッド数) × 複雑度係数 × アクセスパターン係数

複雑度係数 = 1 + (平均メソッド複雑度 / 10)
アクセスパターン係数 = 実際に変数を使用するメソッド数 / 全メソッド数
```

## 🎯 優先実装機能

### Phase 1.5: メソッド検出改善（最優先）

1. **ヘッダーファイルのメソッド宣言検出**
   ```cpp
   // 検出パターン例
   virtual void processData() = 0;  // 純粋仮想関数
   void updateState() override;     // オーバーライド
   static int calculateScore();     // 静的メソッド
   ```

2. **実装ファイルとの関連付け**
   ```cpp
   // ClassName::methodName パターンを検出
   void UICore::processData() {
       // この実装をUICoreクラスに関連付け
   }
   ```

3. **セッション横断的な統合**
   - analyzeコマンド実行時に全ファイルの情報を統合
   - クラスIDとメソッドIDでマッピング

### Phase 2: 詳細解析（--deep）

1. **変数使用パターン分析**
   ```json
   {
     "variable_usage": {
       "m_data": {
         "read_by": ["getData", "processData"],
         "written_by": ["setData", "clearData"],
         "usage_rate": 0.4
       }
     }
   }
   ```

2. **メソッドクラスタリング**
   - 同じ変数群を使用するメソッドをグループ化
   - 独立したグループは分割候補

3. **凝集度メトリクス**
   ```
   LCOM (Lack of Cohesion of Methods) = 
     メソッドペアで共通変数を使わない数 / 全メソッドペア数
   ```

### Phase 3: インテリジェント提案

1. **自動分割提案**
   ```json
   {
     "split_suggestions": [
       {
         "new_class": "UIDataManager",
         "methods": ["loadData", "saveData", "validateData"],
         "variables": ["m_data", "m_dataPath"],
         "reason": "データ管理機能が独立している"
       }
     ]
   }
   ```

2. **リファクタリング優先度**
   - 責務スコア
   - 複雑度
   - 変更頻度（gitログ解析）
   - テストカバレッジ

## 🌍 言語別実装計画

### JavaScript/TypeScript
```javascript
// 検出パターン
class Component {
  constructor() {
    this.state = {};      // メンバ変数
    this.props = null;    // メンバ変数
  }
  
  #privateField = 0;      // プライベートフィールド
  static shared = {};     // 静的変数
}
```

### Python
```python
# 検出パターン
class Analyzer:
    def __init__(self):
        self.data = []          # インスタンス変数
        self._cache = {}        # プライベート慣習
        
    def process(self):
        self.result = None      # 動的追加
```

## 📊 ベンチマーク目標

1. **大規模プロジェクト対応**
   - 10万行以上のコードベース
   - 1000クラス以上
   - 5秒以内に基本解析完了

2. **精度目標**
   - メソッド検出率: 95%以上
   - 変数検出率: 98%以上
   - 誤検出率: 2%以下

## 🚀 実装優先順位

1. **即効性の高い改善**（1週間）
   - メソッド宣言検出
   - クラス::メソッド関連付け
   - 責務スコア表示改善

2. **中期目標**（1ヶ月）
   - JavaScript/TypeScript対応
   - Python対応
   - 変数使用パターン基本実装

3. **長期目標**（3ヶ月）
   - 完全な--deep実装
   - AI支援分割提案
   - VSCode拡張連携

## 🤝 Claude Codeとの連携強化

1. **構造化出力**
   - JSON-LD形式でセマンティック情報付加
   - グラフ構造での依存関係表現

2. **コンテキスト最適化**
   - 関連クラスのみを抽出して提示
   - 変更影響範囲の可視化

3. **提案の具体化**
   ```json
   {
     "refactoring_plan": {
       "step1": "UIDataManagerクラスを作成",
       "step2": "データ関連メソッドを移動",
       "step3": "依存性注入でUIDataManagerを使用",
       "estimated_time": "2時間",
       "risk_level": "low"
     }
   }
   ```

---

## 💡 革新的アイデア

### 1. "責務の重心"可視化
- 各メソッドがどの変数群に依存しているかを2D/3Dマップで表示
- クラスタが見えれば自然な分割点が分かる

### 2. 時系列分析
- git履歴から「一緒に変更される変数とメソッド」を検出
- 実際の開発パターンから最適な分割を提案

### 3. テスト駆動分割
- 既存テストを壊さない分割パターンを優先
- 分割後のテストコード自動生成案

---

この計画により、NekoCodeは単なる静的解析ツールから、インテリジェントなリファクタリング支援ツールへと進化します。Claude Codeとの組み合わせで、大規模レガシーコードの近代化を科学的に支援できるようになります。