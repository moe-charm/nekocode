# NekoCode アナライザー改善計画書

## 1. 目的

`javascript_pegtl_analyzer.hpp` と `typescript_pegtl_analyzer.hpp` に存在する、重複した解析ロジックを排除し、継承関係をより効果的に利用することで、コードの可読性、保守性、拡張性を向上させる。

## 2. 全体方針

1.  **コアロジックの親クラスへの集約:**
    *   行ベースのフォールバック解析 (`apply_line_based_analysis`) や、ネストされた関数の再帰的探索 (`extract_nested_functions_recursively`, `infinite_nested_function_attack`) といった、複雑で共通の処理を、すべて親クラスである `JavaScriptPEGTLAnalyzer` に実装を一本化する。
2.  **仮想関数による拡張ポイントの導入:**
    *   親クラスの解析ロジック内に、言語固有の処理を差し込める「拡張ポイント」として、`virtual` 関数を導入する。
3.  **子クラスのスリム化:**
    *   子クラス `TypeScriptPEGTLAnalyzer` からは重複したロジックを完全に削除し、親から継承した仮想関数をオーバーライド（上書き）することで、TypeScript特有の構文解析ロジックのみを記述する形にリファクタリングする。

---

## 3. `javascript_pegtl_analyzer.hpp` の具体的な修正点

### 3.1. 拡張ポイントとなる仮想関数を追加する

`JavaScriptPEGTLAnalyzer` クラスの `protected` セクションに、以下の仮想関数を追加します。これにより、子クラスが各言語の特性に合わせて処理を拡張できるようになります。

```cpp
// in class JavaScriptPEGTLAnalyzer:
protected:
    // ... 既存の protected メンバー ...

    // 🌟【拡張ポイント】言語固有の関数を抽出するための仮想関数
    // 子クラスはこれをオーバーライドして、独自の関数検出ロジックを実装する。
    virtual void extract_language_specific_functions_from_line(
        const std::string& line,
        size_t line_number,
        AnalysisResult& result,
        std::set<std::string>& existing_functions,
        const std::vector<std::string>& all_lines)
    {
        // JavaScriptの基本実装はここで行う。
        // TypeScriptではこの中身は実行されず、オーバーライドされたものが呼ばれる。
        extract_functions_from_line(line, line_number, result, existing_functions, all_lines);
    }

    // 🌟【拡張ポイント】言語固有のクラスを抽出するための仮想関数
    virtual void extract_language_specific_classes_from_line(
        const std::string& line,
        size_t line_number,
        AnalysisResult& result,
        std::set<std::string>& existing_classes)
    {
        // JavaScriptの基本実装
        extract_classes_from_line(line, line_number, result, existing_classes);
    }
```

### 3.2. 解析ループから仮想関数を呼び出すように変更する

`apply_line_based_analysis` メソッド内の、関数やクラスを抽出しているループ処理を、新しく作成した仮想関数を呼び出すように変更します。

**変更前:**

```cpp
// in apply_line_based_analysis method:
for (size_t i = 0; i < all_lines.size(); i++) {
    const std::string& current_line = all_lines[i];
    size_t current_line_number = i + 1;
    
    extract_functions_from_line(current_line, current_line_number, result, existing_functions, all_lines);
    extract_classes_from_line(current_line, current_line_number, result, existing_classes);
    processed_lines++;
}
```

**変更後:**

```cpp
// in apply_line_based_analysis method:
for (size_t i = 0; i < all_lines.size(); i++) {
    const std::string& current_line = all_lines[i];
    size_t current_line_number = i + 1;
    
    // 仮想関数経由で呼び出すことで、TypeScriptの場合はオーバーライドされたメソッドが呼ばれる
    extract_language_specific_functions_from_line(current_line, current_line_number, result, existing_functions, all_lines);
    extract_language_specific_classes_from_line(current_line, current_line_number, result, existing_classes);
    processed_lines++;
}
```
*(注: `extract_basic_functions_from_line` を呼び出している高速モードのループも同様に `extract_language_specific_functions_from_line` を呼び出すように変更します。ただし、TypeScript側では高速モードでも全パターンを検出するため、この変更によりロジックが統一されます。)*

---

## 4. `typescript_pegtl_analyzer.hpp` の具体的な修正点

### 4.1. 重複しているロジックを大胆に削除する

`TypeScriptPEGTLAnalyzer` クラスから、以下の巨大なメソッド（およびそのヘルパー関数）を**すべて削除**します。これらの機能は親クラスに集約されるため、子クラスでは不要になります。

*   `apply_typescript_line_based_analysis`
*   `double_regex_attack_for_class_methods`
*   `infinite_nested_function_attack`
*   `preprocess_content` (コメント処理関連)
*   `detect_member_variables` (メンバ変数検出)
*   その他、上記メソッドから呼び出されているプライベートヘルパー関数群

### 4.2. `analyze` メソッドをシンプルにする

親クラスの `analyze` メソッドを呼び出し、その結果に対してTypeScript特有の処理を追加する形に `analyze` メソッドを書き換えます。

```cpp
// in class TypeScriptPEGTLAnalyzer:
public:
    AnalysisResult analyze(const std::string& content, const std::string& filename) override {
        // 1. 親クラスの analyze を呼び出して、基本的な解析（コメント除去、PEGTL解析、JSの行ベース解析）をすべて実行させる
        // このとき、内部で呼び出される仮想関数は、下のオーバーライドされたものが使われる
        auto result = JavaScriptPEGTLAnalyzer::analyze(content, filename);

        // 2. TypeScript専用のメンバ変数検出ロジックを呼び出す
        // (親のメンバ変数検出はJavaScript用なので、TypeScript用にオーバーライドしたものを別途呼び出す)
        detect_member_variables(result, content);
        
        // 3. 統計情報を最終更新
        result.update_statistics();
        
        return result;
    }
```

### 4.3. 仮想関数をオーバーライドしてTypeScript専用ロジックを実装する

親クラスで定義した仮想関数を `override` し、中身をTypeScriptの構文解析ロジックに置き換えます。これにより、親の解析フローの中から、適切にTypeScriptの処理が呼び出されるようになります。

```cpp
// in class TypeScriptPEGTLAnalyzer:
protected:
    // 🌟 親の仮想関数をオーバーライド
    void extract_language_specific_functions_from_line(
        const std::string& line,
        size_t line_number,
        AnalysisResult& result,
        std::set<std::string>& existing_functions,
        const std::vector<std::string>& all_lines) override
    {
        // ★★★ ここに、もともと extract_typescript_functions_from_line にあった
        // TypeScript の export function, export const, export async function 等を
        // 検出する正規表現ロジックを記述する ★★★
    }

    // 🌟 親の仮想関数をオーバーライド
    void extract_language_specific_classes_from_line(
        const std::string& line,
        size_t line_number,
        AnalysisResult& result,
        std::set<std::string>& existing_classes) override
    {
        // ★★★ ここに、もともと extract_typescript_classes_from_line や
        // extract_typescript_interfaces_from_line にあった
        // class, interface, type などを検出するロジックを記述する ★★★
    }
    
    // 🌟 メンバ変数検出もオーバーライド
    void detect_member_variables(AnalysisResult& result, const std::string& content) {
        // ★★★ ここに、もともと TypeScriptPEGTLAnalyzer にあった
        // 型注釈 (`public name: string;`) などを考慮したメンバ変数検出ロジックを記述する ★★★
    }
```

## 5. 期待される効果

*   **コード量の削減:** `typescript_pegtl_analyzer.hpp` が大幅にスリム化される。
*   **保守性の向上:** 解析アルゴリズムの修正が親クラスの一箇所で済むようになる。
*   **拡張性の向上:** 新しいECMAScriptの機能をサポートする際、JavaScript側に追加すれば、TypeScriptにも自動で恩恵が及ぶ。また、将来的に他のAltJS（例: CoffeeScript）のアナライザーを作る場合も、`JavaScriptPEGTLAnalyzer` を継承することで容易に開発が可能になる。
