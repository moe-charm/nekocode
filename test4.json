🔄 Using parallel processing path
[23:18:31.339] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/base_analyzer.hpp (7212 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=65, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=0, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:31.339] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 173行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 173行処理 (133ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 4, Functions: 9
🔍 Debug: Classes before=1, after=4, Functions before=0, after=9
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-26 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: #pragma once
📄 Line 2 (in_class=1, brace_depth=0): 
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Processing class: 'BaseAnalyzer'
🎯 Found correct class 'BaseAnalyzer' at line 43
✅ Corrected start_line for 'BaseAnalyzer': 43
🔍 Scanning lines 43-146 for class 'BaseAnalyzer'
🎯 Class start detected at line 43: class BaseAnalyzer {
📄 Line 44 (in_class=1, brace_depth=1): public:
📄 Line 45 (in_class=1, brace_depth=1):     virtual ~BaseAnalyzer() = default;
📄 Line 46 (in_class=1, brace_depth=1):     
📄 Line 47 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 48 (in_class=1, brace_depth=1):     // 🔍 純粋仮想関数 - 各言語で実装必須
📄 Line 49 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 50 (in_class=1, brace_depth=1):     
📄 Line 51 (in_class=1, brace_depth=1):     /// 言語タイプを返す
📄 Line 52 (in_class=1, brace_depth=1):     virtual Language get_language() const = 0;
📄 Line 53 (in_class=1, brace_depth=1):     
📄 Line 54 (in_class=1, brace_depth=1):     /// メイン解析関数
📄 Line 55 (in_class=1, brace_depth=1):     virtual AnalysisResult analyze(const std::string& content, const std::string& filename) = 0;
📄 Line 56 (in_class=1, brace_depth=1):     
📄 Line 57 (in_class=1, brace_depth=1):     /// 言語名を返す（表示用）
📄 Line 58 (in_class=1, brace_depth=1):     virtual std::string get_language_name() const = 0;
📄 Line 59 (in_class=1, brace_depth=1):     
📄 Line 60 (in_class=1, brace_depth=1):     /// サポートする拡張子を返す
📄 Line 61 (in_class=1, brace_depth=1):     virtual std::vector<std::string> get_supported_extensions() const = 0;
📄 Line 62 (in_class=1, brace_depth=1):     
📄 Line 63 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 64 (in_class=1, brace_depth=1):     // 🛠️ 共通ユーティリティ関数（std::regex不使用）
📄 Line 65 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 66 (in_class=1, brace_depth=1):     
📄 Line 67 (in_class=1, brace_depth=1): protected:
📄 Line 68 (in_class=1, brace_depth=1):     /// 行番号計算（共通処理）
📄 Line 69 (in_class=1, brace_depth=1):     uint32_t calculate_line_number(const std::string& content, size_t position) {
📄 Line 70 (in_class=1, brace_depth=2):         if (position >= content.length()) {
📄 Line 71 (in_class=1, brace_depth=3):             return 1;
🎯 Found member variable: 1 in class BaseAnalyzer at line 71
    📝 Line content: '            return 1;'
📄 Line 72 (in_class=1, brace_depth=3):         }
📄 Line 73 (in_class=1, brace_depth=2):         
📄 Line 74 (in_class=1, brace_depth=2):         uint32_t line_count = 1;
🎯 Found member variable: line_count in class BaseAnalyzer at line 74
    📝 Line content: '        uint32_t line_count = 1;'
📄 Line 75 (in_class=1, brace_depth=2):         for (size_t i = 0; i < position; ++i) {
📄 Line 76 (in_class=1, brace_depth=3):             if (content[i] == '\n') {
📄 Line 77 (in_class=1, brace_depth=4):                 line_count++;
📄 Line 78 (in_class=1, brace_depth=4):             }
📄 Line 79 (in_class=1, brace_depth=3):         }
📄 Line 80 (in_class=1, brace_depth=2):         return line_count;
🎯 Found member variable: line_count in class BaseAnalyzer at line 80
    📝 Line content: '        return line_count;'
📄 Line 81 (in_class=1, brace_depth=2):     }
📄 Line 82 (in_class=1, brace_depth=1):     
📄 Line 83 (in_class=1, brace_depth=1):     /// 基本的な複雑度計算（std::regex不使用版）
📄 Line 84 (in_class=1, brace_depth=1):     virtual ComplexityInfo calculate_complexity(const std::string& content) {
📄 Line 85 (in_class=1, brace_depth=2):         ComplexityInfo complexity;
🎯 Found member variable: complexity in class BaseAnalyzer at line 85
    📝 Line content: '        ComplexityInfo complexity;'
📄 Line 86 (in_class=1, brace_depth=2):         complexity.cyclomatic_complexity = 1; // ベーススコア
📄 Line 87 (in_class=1, brace_depth=2):         
📄 Line 88 (in_class=1, brace_depth=2):         // 言語共通のキーワード
📄 Line 89 (in_class=1, brace_depth=2):         std::vector<std::string> complexity_keywords = {
📄 Line 90 (in_class=1, brace_depth=3):             "if", "else", "for", "while", "switch", "case", "catch"
📄 Line 91 (in_class=1, brace_depth=3):         };
📄 Line 92 (in_class=1, brace_depth=2):         
📄 Line 93 (in_class=1, brace_depth=2):         // ⚠️ 注意: std::regexは使わない！単純な文字列検索で実装
📄 Line 94 (in_class=1, brace_depth=2):         for (const auto& keyword : complexity_keywords) {
📄 Line 95 (in_class=1, brace_depth=3):             size_t pos = 0;
🎯 Found member variable: pos in class BaseAnalyzer at line 95
    📝 Line content: '            size_t pos = 0;'
📄 Line 96 (in_class=1, brace_depth=3):             while ((pos = content.find(keyword, pos)) != std::string::npos) {
📄 Line 97 (in_class=1, brace_depth=4):                 // 単語境界チェック（簡易版）
📄 Line 98 (in_class=1, brace_depth=4):                 if ((pos == 0 || !std::isalnum(content[pos-1])) &&
📄 Line 99 (in_class=1, brace_depth=4):                     (pos + keyword.length() >= content.length() || 
📄 Line 100 (in_class=1, brace_depth=4):                      !std::isalnum(content[pos + keyword.length()]))) {
📄 Line 101 (in_class=1, brace_depth=5):                     complexity.cyclomatic_complexity++;
📄 Line 102 (in_class=1, brace_depth=5):                 }
📄 Line 103 (in_class=1, brace_depth=4):                 pos += keyword.length();
📄 Line 104 (in_class=1, brace_depth=4):             }
📄 Line 105 (in_class=1, brace_depth=3):         }
📄 Line 106 (in_class=1, brace_depth=2):         
📄 Line 107 (in_class=1, brace_depth=2):         complexity.update_rating();
📄 Line 108 (in_class=1, brace_depth=2):         return complexity;
🎯 Found member variable: complexity in class BaseAnalyzer at line 108
    📝 Line content: '        return complexity;'
📄 Line 109 (in_class=1, brace_depth=2):     }
📄 Line 110 (in_class=1, brace_depth=1):     
📄 Line 111 (in_class=1, brace_depth=1):     // 🛡️ 単純な文字列処理ヘルパー（std::regexの代替）
📄 Line 112 (in_class=1, brace_depth=1):     
📄 Line 113 (in_class=1, brace_depth=1):     /// 次の単語を抽出
📄 Line 114 (in_class=1, brace_depth=1):     std::string extract_next_word(const std::string& content, size_t& pos) {
📄 Line 115 (in_class=1, brace_depth=2):         // 空白をスキップ
📄 Line 116 (in_class=1, brace_depth=2):         while (pos < content.length() && std::isspace(content[pos])) {
📄 Line 117 (in_class=1, brace_depth=3):             pos++;
📄 Line 118 (in_class=1, brace_depth=3):         }
📄 Line 119 (in_class=1, brace_depth=2):         
📄 Line 120 (in_class=1, brace_depth=2):         size_t start = pos;
🎯 Found member variable: start in class BaseAnalyzer at line 120
    📝 Line content: '        size_t start = pos;'
📄 Line 121 (in_class=1, brace_depth=2):         while (pos < content.length() && (std::isalnum(content[pos]) || content[pos] == '_')) {
📄 Line 122 (in_class=1, brace_depth=3):             pos++;
📄 Line 123 (in_class=1, brace_depth=3):         }
📄 Line 124 (in_class=1, brace_depth=2):         
📄 Line 125 (in_class=1, brace_depth=2):         return content.substr(start, pos - start);
📄 Line 126 (in_class=1, brace_depth=2):     }
📄 Line 127 (in_class=1, brace_depth=1):     
📄 Line 128 (in_class=1, brace_depth=1):     /// 特定の文字までスキップ
📄 Line 129 (in_class=1, brace_depth=1):     void skip_until(const std::string& content, size_t& pos, char target) {
📄 Line 130 (in_class=1, brace_depth=2):         while (pos < content.length() && content[pos] != target) {
📄 Line 131 (in_class=1, brace_depth=3):             pos++;
📄 Line 132 (in_class=1, brace_depth=3):         }
📄 Line 133 (in_class=1, brace_depth=2):     }
📄 Line 134 (in_class=1, brace_depth=1):     
📄 Line 135 (in_class=1, brace_depth=1):     /// 文字列リテラルをスキップ
📄 Line 136 (in_class=1, brace_depth=1):     void skip_string_literal(const std::string& content, size_t& pos, char quote) {
📄 Line 137 (in_class=1, brace_depth=2):         if (pos < content.length() && content[pos] == quote) {
📄 Line 138 (in_class=1, brace_depth=3):             pos++; // 開始クォート
📄 Line 139 (in_class=1, brace_depth=3):             while (pos < content.length()) {
📄 Line 140 (in_class=1, brace_depth=4):                 if (content[pos] == '\\' && pos + 1 < content.length()) {
📄 Line 141 (in_class=1, brace_depth=5):                     pos += 2; // エスケープシーケンス
📄 Line 142 (in_class=1, brace_depth=5):                 } else if (content[pos] == quote) {
📄 Line 143 (in_class=1, brace_depth=5):                     pos++; // 終了クォート
📄 Line 144 (in_class=1, brace_depth=5):                     break;
📄 Line 145 (in_class=1, brace_depth=5):                 } else {
📄 Line 146 (in_class=1, brace_depth=5):                     pos++;
📍 Reached end_line 146 for class BaseAnalyzer
🔍 Processing class: 'AnalyzerFactory'
🎯 Found correct class 'AnalyzerFactory' at line 157
✅ Corrected start_line for 'AnalyzerFactory': 157
🔍 Scanning lines 157-183 for class 'AnalyzerFactory'
🎯 Class start detected at line 157: class AnalyzerFactory {
📄 Line 158 (in_class=1, brace_depth=1): public:
📄 Line 159 (in_class=1, brace_depth=1):     /// 言語に応じたアナライザーを生成
📄 Line 160 (in_class=1, brace_depth=1):     static std::unique_ptr<BaseAnalyzer> create_analyzer(Language language);
📄 Line 161 (in_class=1, brace_depth=1):     
📄 Line 162 (in_class=1, brace_depth=1):     /// ファイル拡張子からアナライザーを生成
📄 Line 163 (in_class=1, brace_depth=1):     static std::unique_ptr<BaseAnalyzer> create_analyzer_from_extension(const std::string& extension);
📄 Line 164 (in_class=1, brace_depth=1):     
📄 Line 165 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 166 (in_class=1, brace_depth=1):     // 🎮 Unity 特化ファクトリー関数
📄 Line 167 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 168 (in_class=1, brace_depth=1):     
📄 Line 169 (in_class=1, brace_depth=1):     /// Unity analyzer を直接生成
📄 Line 170 (in_class=1, brace_depth=1):     static std::unique_ptr<BaseAnalyzer> create_unity_analyzer();
📄 Line 171 (in_class=1, brace_depth=1):     
📄 Line 172 (in_class=1, brace_depth=1):     /// ファイル内容からUnity analyzer を自動選択生成
📄 Line 173 (in_class=1, brace_depth=1):     static std::unique_ptr<BaseAnalyzer> create_unity_analyzer_from_file(
📄 Line 174 (in_class=1, brace_depth=1):         const std::string& filename, 
📄 Line 175 (in_class=1, brace_depth=1):         const std::string& content_preview
📄 Line 176 (in_class=1, brace_depth=1):     );
📄 Line 177 (in_class=1, brace_depth=1):     
📄 Line 178 (in_class=1, brace_depth=1): private:
📄 Line 179 (in_class=1, brace_depth=1):     /// ファイル拡張子を取得
📄 Line 180 (in_class=1, brace_depth=1):     static std::string get_extension(const std::string& filename);
📄 Line 181 (in_class=1, brace_depth=1): };
🔍 Before update_statistics: classes=4, functions=9
🔍 After update_statistics: stats.class_count=4, stats.function_count=9
[23:18:31.533] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/base_analyzer.hpp
🔥 Final return: result.stats.class_count=4, result.stats.function_count=9
[23:18:31.533] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/analyzer_factory.cpp (6772 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=103, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=0, has_struct=0, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:31.533] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 158行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 158行処理 (122ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 0
🔍 Debug: Classes before=1, after=2, Functions before=0, after=0
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-12 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🏭 Analyzer Factory - 言語別アナライザー生成ファクトリー
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=0
🔍 After update_statistics: stats.class_count=2, stats.function_count=0
[23:18:31.657] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/analyzer_factory.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=0
[23:18:31.657] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/typescript/typescript_pegtl_analyzer.hpp (76196 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=801, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=1, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:31.658] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 1518行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 1518行処理 (1176ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 4, Functions: 52
🔍 Debug: Classes before=1, after=4, Functions before=0, after=52
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-12 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: #pragma once
📄 Line 2 (in_class=1, brace_depth=0): 
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Processing class: 'TypeScriptPEGTLAnalyzer'
🎯 Found correct class 'TypeScriptPEGTLAnalyzer' at line 29
✅ Corrected start_line for 'TypeScriptPEGTLAnalyzer': 29
🔍 Scanning lines 29-778 for class 'TypeScriptPEGTLAnalyzer'
🎯 Class start detected at line 29: class TypeScriptPEGTLAnalyzer : public JavaScriptPEGTLAnalyzer {
📄 Line 30 (in_class=1, brace_depth=1): public:
📄 Line 31 (in_class=1, brace_depth=1):     TypeScriptPEGTLAnalyzer() = default;
📄 Line 32 (in_class=1, brace_depth=1):     ~TypeScriptPEGTLAnalyzer() override = default;
📄 Line 33 (in_class=1, brace_depth=1):     
📄 Line 34 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 35 (in_class=1, brace_depth=1):     // 🔍 BaseAnalyzer インターフェース実装（オーバーライド）
📄 Line 36 (in_class=1, brace_depth=1):     //=========================================================================
📄 Line 37 (in_class=1, brace_depth=1):     
📄 Line 38 (in_class=1, brace_depth=1):     Language get_language() const override {
📄 Line 39 (in_class=1, brace_depth=2):         return Language::TYPESCRIPT;
📄 Line 40 (in_class=1, brace_depth=2):     }
📄 Line 41 (in_class=1, brace_depth=1):     
📄 Line 42 (in_class=1, brace_depth=1):     std::string get_language_name() const override {
📄 Line 43 (in_class=1, brace_depth=2):         return "TypeScript (PEGTL)";
📄 Line 44 (in_class=1, brace_depth=2):     }
📄 Line 45 (in_class=1, brace_depth=1):     
📄 Line 46 (in_class=1, brace_depth=1):     std::vector<std::string> get_supported_extensions() const override {
📄 Line 47 (in_class=1, brace_depth=2):         return {".ts", ".tsx", ".mts", ".cts"};
📄 Line 48 (in_class=1, brace_depth=2):     }
📄 Line 49 (in_class=1, brace_depth=1):     
📄 Line 50 (in_class=1, brace_depth=1):     AnalysisResult analyze(const std::string& content, const std::string& filename) override {
📄 Line 51 (in_class=1, brace_depth=2):         // 🕐 全体の処理時間測定開始
📄 Line 52 (in_class=1, brace_depth=2):         auto total_start = std::chrono::high_resolution_clock::now();
🎯 Found member variable: total_start in class TypeScriptPEGTLAnalyzer at line 52
    📝 Line content: '        auto total_start = std::chrono::high_resolution_clock::now();'
📄 Line 53 (in_class=1, brace_depth=2):         
📄 Line 54 (in_class=1, brace_depth=2):         // 🔥 前処理革命：コメント・文字列除去システム（Gemini先生戦略！）
📄 Line 55 (in_class=1, brace_depth=2):         auto preprocess_start = std::chrono::high_resolution_clock::now();
🎯 Found member variable: preprocess_start in class TypeScriptPEGTLAnalyzer at line 55
    📝 Line content: '        auto preprocess_start = std::chrono::high_resolution_clock::now();'
📄 Line 56 (in_class=1, brace_depth=2):         std::string preprocessed_content = preprocess_content(content);
🎯 Found member variable: preprocessed_content in class TypeScriptPEGTLAnalyzer at line 56
    📝 Line content: '        std::string preprocessed_content = preprocess_content(content);'
📄 Line 57 (in_class=1, brace_depth=2):         auto preprocess_end = std::chrono::high_resolution_clock::now();
🎯 Found member variable: preprocess_end in class TypeScriptPEGTLAnalyzer at line 57
    📝 Line content: '        auto preprocess_end = std::chrono::high_resolution_clock::now();'
📄 Line 58 (in_class=1, brace_depth=2):         
📄 Line 59 (in_class=1, brace_depth=2):         // 安全な削減量計算（アンダーフロー防止）
📄 Line 60 (in_class=1, brace_depth=2):         long long size_diff = static_cast<long long>(content.length()) - static_cast<long long>(preprocessed_content.length());
📄 Line 61 (in_class=1, brace_depth=2):         std::cerr << "🧹 前処理完了: " << content.length() << " → " << preprocessed_content.length() 
📄 Line 62 (in_class=1, brace_depth=2):                   << " bytes (削減: " << size_diff << ")" << std::endl;
📄 Line 63 (in_class=1, brace_depth=2):         
📄 Line 64 (in_class=1, brace_depth=2):         // 基本的にJavaScript PEGTLの解析を使用（ハイブリッド戦略含む）
📄 Line 65 (in_class=1, brace_depth=2):         auto result = JavaScriptPEGTLAnalyzer::analyze(preprocessed_content, filename);
🎯 Found member variable: result in class TypeScriptPEGTLAnalyzer at line 65
    📝 Line content: '        auto result = JavaScriptPEGTLAnalyzer::analyze(preprocessed_content, filename);'
📄 Line 66 (in_class=1, brace_depth=2):         
📄 Line 67 (in_class=1, brace_depth=2):         std::cerr << "📜 TypeScript analyzer: Base JS detected classes=" << result.classes.size() 
📄 Line 68 (in_class=1, brace_depth=2):                   << ", functions=" << result.functions.size() << std::endl;
📄 Line 69 (in_class=1, brace_depth=2):         
📄 Line 70 (in_class=1, brace_depth=2):         // 🚀 TypeScript特有のハイブリッド戦略追加
📄 Line 71 (in_class=1, brace_depth=2):         if (needs_typescript_specific_analysis(result, preprocessed_content)) {
📄 Line 72 (in_class=1, brace_depth=3):             std::cerr << "📜 TypeScript specific analysis triggered!" << std::endl;
📄 Line 73 (in_class=1, brace_depth=3):             apply_typescript_line_based_analysis(result, preprocessed_content, filename);
📄 Line 74 (in_class=1, brace_depth=3):         }
📄 Line 75 (in_class=1, brace_depth=2):         
📄 Line 76 (in_class=1, brace_depth=2):         // 🔍 TypeScript メンバ変数検出（JavaScript成功パターン移植）
📄 Line 77 (in_class=1, brace_depth=2):         detect_member_variables(result, content);
📄 Line 78 (in_class=1, brace_depth=2):         
📄 Line 79 (in_class=1, brace_depth=2):         // TypeScript専用の追加解析（将来的に実装）
📄 Line 80 (in_class=1, brace_depth=2):         // - interface検出
📄 Line 81 (in_class=1, brace_depth=2):         // - type alias検出  
📄 Line 82 (in_class=1, brace_depth=2):         // - enum検出
📄 Line 83 (in_class=1, brace_depth=2):         // - namespace検出
📄 Line 84 (in_class=1, brace_depth=2):         // - ジェネリクス解析
📄 Line 85 (in_class=1, brace_depth=2):         
📄 Line 86 (in_class=1, brace_depth=2):         // デバッグ用: TypeScript検出マーカー
📄 Line 87 (in_class=1, brace_depth=2):         if (!result.classes.empty() && result.classes[0].name == "JS_PEGTL_ANALYZER_CALLED") {
📄 Line 88 (in_class=1, brace_depth=3):             result.classes[0].name = "TS_PEGTL_ANALYZER_CALLED";
📄 Line 89 (in_class=1, brace_depth=3):         }
📄 Line 90 (in_class=1, brace_depth=2):         
📄 Line 91 (in_class=1, brace_depth=2):         return result;
🎯 Found member variable: result in class TypeScriptPEGTLAnalyzer at line 91
    📝 Line content: '        return result;'
📄 Line 92 (in_class=1, brace_depth=2):     }
📄 Line 93 (in_class=1, brace_depth=1): 
📄 Line 94 (in_class=1, brace_depth=1): private:
📄 Line 95 (in_class=1, brace_depth=1):     // 🚀 TypeScript特有のハイブリッド戦略: 統計整合性チェック
📄 Line 96 (in_class=1, brace_depth=1):     bool needs_typescript_specific_analysis(const AnalysisResult& result, const std::string& content) {
📄 Line 97 (in_class=1, brace_depth=2):         uint32_t complexity = result.complexity.cyclomatic_complexity;
🎯 Found member variable: complexity in class TypeScriptPEGTLAnalyzer at line 97
    📝 Line content: '        uint32_t complexity = result.complexity.cyclomatic_complexity;'
📄 Line 98 (in_class=1, brace_depth=2):         size_t detected_functions = result.functions.size();
🎯 Found member variable: detected_functions in class TypeScriptPEGTLAnalyzer at line 98
    📝 Line content: '        size_t detected_functions = result.functions.size();'
📄 Line 99 (in_class=1, brace_depth=2):         
📄 Line 100 (in_class=1, brace_depth=2):         // TypeScript大規模ファイルの特別チェック
📄 Line 101 (in_class=1, brace_depth=2):         if (complexity > 200 && detected_functions < 20) {
📄 Line 102 (in_class=1, brace_depth=3):             return true;
🎯 Found member variable: true in class TypeScriptPEGTLAnalyzer at line 102
    📝 Line content: '            return true;'
📄 Line 103 (in_class=1, brace_depth=3):         }
📄 Line 104 (in_class=1, brace_depth=2):         
📄 Line 105 (in_class=1, brace_depth=2):         // TypeScript特有のパターンがある場合
📄 Line 106 (in_class=1, brace_depth=2):         if (content.find("export function") != std::string::npos ||
📄 Line 107 (in_class=1, brace_depth=2):             content.find("export const") != std::string::npos ||
📄 Line 108 (in_class=1, brace_depth=2):             content.find("export async") != std::string::npos) {
📄 Line 109 (in_class=1, brace_depth=3):             return true;
🎯 Found member variable: true in class TypeScriptPEGTLAnalyzer at line 109
    📝 Line content: '            return true;'
📄 Line 110 (in_class=1, brace_depth=3):         }
📄 Line 111 (in_class=1, brace_depth=2):         
📄 Line 112 (in_class=1, brace_depth=2):         return false;
🎯 Found member variable: false in class TypeScriptPEGTLAnalyzer at line 112
    📝 Line content: '        return false;'
📄 Line 113 (in_class=1, brace_depth=2):     }
📄 Line 114 (in_class=1, brace_depth=1):     
📄 Line 115 (in_class=1, brace_depth=1):     // 🚀 TypeScript特有の二重正規表現アタック解析
📄 Line 116 (in_class=1, brace_depth=1):     void apply_typescript_line_based_analysis(AnalysisResult& result, const std::string& content, const std::string& filename) {
📄 Line 117 (in_class=1, brace_depth=2):         std::istringstream stream(content);
📄 Line 118 (in_class=1, brace_depth=2):         std::string line;
🎯 Found member variable: line in class TypeScriptPEGTLAnalyzer at line 118
    📝 Line content: '        std::string line;'
📄 Line 119 (in_class=1, brace_depth=2):         size_t line_number = 1;
🎯 Found member variable: line_number in class TypeScriptPEGTLAnalyzer at line 119
    📝 Line content: '        size_t line_number = 1;'
📄 Line 120 (in_class=1, brace_depth=2):         
📄 Line 121 (in_class=1, brace_depth=2):         // 既存の関数名を記録（重複検出を防ぐ）
📄 Line 122 (in_class=1, brace_depth=2):         std::set<std::string> existing_functions;
🎯 Found member variable: existing_functions in class TypeScriptPEGTLAnalyzer at line 122
    📝 Line content: '        std::set<std::string> existing_functions;'
📄 Line 123 (in_class=1, brace_depth=2):         for (const auto& func : result.functions) {
📄 Line 124 (in_class=1, brace_depth=3):             existing_functions.insert(func.name);
📄 Line 125 (in_class=1, brace_depth=3):         }
📄 Line 126 (in_class=1, brace_depth=2):         
📄 Line 127 (in_class=1, brace_depth=2):         // 既存のクラス名を記録（重複検出を防ぐ）
📄 Line 128 (in_class=1, brace_depth=2):         std::set<std::string> existing_classes;
🎯 Found member variable: existing_classes in class TypeScriptPEGTLAnalyzer at line 128
    📝 Line content: '        std::set<std::string> existing_classes;'
📄 Line 129 (in_class=1, brace_depth=2):         for (const auto& cls : result.classes) {
📄 Line 130 (in_class=1, brace_depth=3):             existing_classes.insert(cls.name);
📄 Line 131 (in_class=1, brace_depth=3):         }
📄 Line 132 (in_class=1, brace_depth=2):         
📄 Line 133 (in_class=1, brace_depth=2):         // 🎯 ファイルサイズ検出と戦略決定（JavaScript高速化技術を逆輸入！）
📄 Line 134 (in_class=1, brace_depth=2):         std::vector<std::string> all_lines;
🎯 Found member variable: all_lines in class TypeScriptPEGTLAnalyzer at line 134
    📝 Line content: '        std::vector<std::string> all_lines;'
📄 Line 135 (in_class=1, brace_depth=2):         while (std::getline(stream, line)) {
📄 Line 136 (in_class=1, brace_depth=3):             all_lines.push_back(line);
📄 Line 137 (in_class=1, brace_depth=3):         }
📄 Line 138 (in_class=1, brace_depth=2):         
📄 Line 139 (in_class=1, brace_depth=2):         const size_t total_lines = all_lines.size();
🎯 Found member variable: total_lines in class TypeScriptPEGTLAnalyzer at line 139
    📝 Line content: '        const size_t total_lines = all_lines.size();'
📄 Line 140 (in_class=1, brace_depth=2):         const bool use_full_analysis = total_lines < 15000;     // 15K行未満で全機能（JavaScript戦略移植）
🎯 Found member variable: use_full_analysis in class TypeScriptPEGTLAnalyzer at line 140
    📝 Line content: '        const bool use_full_analysis = total_lines < 15000;     // 15K行未満で全機能（JavaScript戦略移植）'
📄 Line 141 (in_class=1, brace_depth=2):         const bool use_sampling_mode = total_lines >= 15000 && total_lines < 40000;  // サンプリングモード（JavaScript戦略移植）
🎯 Found member variable: use_sampling_mode in class TypeScriptPEGTLAnalyzer at line 141
    📝 Line content: '        const bool use_sampling_mode = total_lines >= 15000 && total_lines < 40000;  // サンプリングモード（JavaScript戦略移植）'
📄 Line 142 (in_class=1, brace_depth=2):         const bool use_high_speed_mode = total_lines >= 40000;  // 🚀 【JavaScript逆輸入】40K行超で高速モード
🎯 Found member variable: use_high_speed_mode in class TypeScriptPEGTLAnalyzer at line 142
    📝 Line content: '        const bool use_high_speed_mode = total_lines >= 40000;  // 🚀 【JavaScript逆輸入】40K行超で高速モード'
📄 Line 143 (in_class=1, brace_depth=2):         
📄 Line 144 (in_class=1, brace_depth=2):         std::cerr << "📊 ファイル情報: " << total_lines << "行検出" << std::endl;
📄 Line 145 (in_class=1, brace_depth=2):         
📄 Line 146 (in_class=1, brace_depth=2):         // 🔧 デバッグモードでのみ詳細情報表示
📄 Line 147 (in_class=1, brace_depth=2):         if (g_debug_mode) {
📄 Line 148 (in_class=1, brace_depth=3):             std::cerr << "🔧 デバッグ: total_lines=" << total_lines << std::endl;
📄 Line 149 (in_class=1, brace_depth=3):             std::cerr << "🔧 デバッグ: use_full_analysis=" << use_full_analysis << std::endl;
📄 Line 150 (in_class=1, brace_depth=3):             std::cerr << "🔧 デバッグ: use_sampling_mode=" << use_sampling_mode << std::endl;
📄 Line 151 (in_class=1, brace_depth=3):             std::cerr << "🔧 デバッグ: use_high_speed_mode=" << use_high_speed_mode << std::endl;
📄 Line 152 (in_class=1, brace_depth=3):             std::cerr << "🔧 デバッグ: 40000以上か? " << (total_lines >= 40000) << std::endl;
📄 Line 153 (in_class=1, brace_depth=3):         }
📄 Line 154 (in_class=1, brace_depth=2):         
📄 Line 155 (in_class=1, brace_depth=2):         // 第1段階: 行ベース解析（JavaScript戦略移植版）
📄 Line 156 (in_class=1, brace_depth=2):         size_t processed_lines = 0;
🎯 Found member variable: processed_lines in class TypeScriptPEGTLAnalyzer at line 156
    📝 Line content: '        size_t processed_lines = 0;'
📄 Line 157 (in_class=1, brace_depth=2):         auto analysis_start = std::chrono::high_resolution_clock::now();
🎯 Found member variable: analysis_start in class TypeScriptPEGTLAnalyzer at line 157
    📝 Line content: '        auto analysis_start = std::chrono::high_resolution_clock::now();'
📄 Line 158 (in_class=1, brace_depth=2):         
📄 Line 159 (in_class=1, brace_depth=2):         if (use_full_analysis) {
📄 Line 160 (in_class=1, brace_depth=3):             std::cerr << "🚀 通常モード: 全機能有効（JavaScript戦略移植）" << std::endl;
📄 Line 161 (in_class=1, brace_depth=3):             // 通常モード：全行処理
📄 Line 162 (in_class=1, brace_depth=3):             for (size_t i = 0; i < all_lines.size(); i++) {
📄 Line 163 (in_class=1, brace_depth=4):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class TypeScriptPEGTLAnalyzer at line 163
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 164 (in_class=1, brace_depth=4):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class TypeScriptPEGTLAnalyzer at line 164
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 165 (in_class=1, brace_depth=4):                 
📄 Line 166 (in_class=1, brace_depth=4):                 extract_typescript_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 167 (in_class=1, brace_depth=4):                 processed_lines++;
📄 Line 168 (in_class=1, brace_depth=4):             }
📄 Line 169 (in_class=1, brace_depth=3):         } else if (use_sampling_mode) {
📄 Line 170 (in_class=1, brace_depth=3):             std::cerr << "🎲 サンプリングモード: 10行に1行処理（JavaScript戦略移植）" << std::endl;
📄 Line 171 (in_class=1, brace_depth=3):             // サンプリングモード：10行に1行だけ処理
📄 Line 172 (in_class=1, brace_depth=3):             for (size_t i = 0; i < all_lines.size(); i += 10) {
📄 Line 173 (in_class=1, brace_depth=4):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class TypeScriptPEGTLAnalyzer at line 173
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 174 (in_class=1, brace_depth=4):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class TypeScriptPEGTLAnalyzer at line 174
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 175 (in_class=1, brace_depth=4):                 
📄 Line 176 (in_class=1, brace_depth=4):                 extract_typescript_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 177 (in_class=1, brace_depth=4):                 processed_lines++;
📄 Line 178 (in_class=1, brace_depth=4):             }
📄 Line 179 (in_class=1, brace_depth=3):         } else if (use_high_speed_mode) {
📄 Line 180 (in_class=1, brace_depth=3):             std::cerr << "⚡ 高速モード: 基本検出のみ（JavaScript戦略移植・Geminiスキップ）" << std::endl;
📄 Line 181 (in_class=1, brace_depth=3):             // 高速モード：基本検出のみ
📄 Line 182 (in_class=1, brace_depth=3):             for (size_t i = 0; i < all_lines.size(); i++) {
📄 Line 183 (in_class=1, brace_depth=4):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class TypeScriptPEGTLAnalyzer at line 183
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 184 (in_class=1, brace_depth=4):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class TypeScriptPEGTLAnalyzer at line 184
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 185 (in_class=1, brace_depth=4):                 
📄 Line 186 (in_class=1, brace_depth=4):                 // 🚀 【JavaScript高速化技術完全移植】基本パターンのみ検出（Gemini攻撃停止！）
📄 Line 187 (in_class=1, brace_depth=4):                 extract_basic_typescript_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 188 (in_class=1, brace_depth=4):                 processed_lines++;
📄 Line 189 (in_class=1, brace_depth=4):                 
📄 Line 190 (in_class=1, brace_depth=4):                 // 🚫 JavaScript高速化戦略：クラス・Gemini検出を停止で大幅高速化！
📄 Line 191 (in_class=1, brace_depth=4):                 // extract_typescript_classes_from_line - 停止
📄 Line 192 (in_class=1, brace_depth=4):                 // extract_typescript_interfaces_from_line - 停止
📄 Line 193 (in_class=1, brace_depth=4):                 // gemini_line_level_double_attack - 停止
📄 Line 194 (in_class=1, brace_depth=4):             }
📄 Line 195 (in_class=1, brace_depth=3):         } else if (use_sampling_mode) {
📄 Line 196 (in_class=1, brace_depth=3):             std::cerr << "🎲 サンプリングモード: 10行に1行処理（JavaScript戦略移植）" << std::endl;
📄 Line 197 (in_class=1, brace_depth=3):             // サンプリングモード：10行に1行だけ処理
📄 Line 198 (in_class=1, brace_depth=3):             for (size_t i = 0; i < all_lines.size(); i += 10) {
📄 Line 199 (in_class=1, brace_depth=4):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class TypeScriptPEGTLAnalyzer at line 199
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 200 (in_class=1, brace_depth=4):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class TypeScriptPEGTLAnalyzer at line 200
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 201 (in_class=1, brace_depth=4):                 
📄 Line 202 (in_class=1, brace_depth=4):                 // 🚀 【JavaScript高速化技術移植】サンプリングモードでもシンプルに！
📄 Line 203 (in_class=1, brace_depth=4):                 extract_basic_typescript_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 204 (in_class=1, brace_depth=4):                 processed_lines++;
📄 Line 205 (in_class=1, brace_depth=4):                 
📄 Line 206 (in_class=1, brace_depth=4):                 // 🚫 JavaScript高速化戦略：サンプリングでもGemini停止で大幅高速化！
📄 Line 207 (in_class=1, brace_depth=4):                 // extract_typescript_functions_from_line - 停止  
📄 Line 208 (in_class=1, brace_depth=4):                 // extract_typescript_classes_from_line - 停止
📄 Line 209 (in_class=1, brace_depth=4):                 // extract_typescript_interfaces_from_line - 停止
📄 Line 210 (in_class=1, brace_depth=4):                 // gemini_line_level_double_attack - 停止
📄 Line 211 (in_class=1, brace_depth=4):             }
📄 Line 212 (in_class=1, brace_depth=3):         } else if (use_high_speed_mode) {
📄 Line 213 (in_class=1, brace_depth=3):             std::cerr << "⚡ 高速モード: 基本検出のみ（JavaScript戦略移植・Geminiスキップ）" << std::endl;
📄 Line 214 (in_class=1, brace_depth=3):             // 高速モード：基本検出のみ
📄 Line 215 (in_class=1, brace_depth=3):             for (size_t i = 0; i < all_lines.size(); i++) {
📄 Line 216 (in_class=1, brace_depth=4):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class TypeScriptPEGTLAnalyzer at line 216
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 217 (in_class=1, brace_depth=4):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class TypeScriptPEGTLAnalyzer at line 217
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 218 (in_class=1, brace_depth=4):                 
📄 Line 219 (in_class=1, brace_depth=4):                 // 基本的なTypeScript関数パターンのみ検出（JavaScript版extract_basic_functions_from_lineベース）
📄 Line 220 (in_class=1, brace_depth=4):                 extract_basic_typescript_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 221 (in_class=1, brace_depth=4):                 processed_lines++;
📄 Line 222 (in_class=1, brace_depth=4):             }
📄 Line 223 (in_class=1, brace_depth=3):         }
📄 Line 224 (in_class=1, brace_depth=2):         
📄 Line 225 (in_class=1, brace_depth=2):         auto analysis_end = std::chrono::high_resolution_clock::now();
🎯 Found member variable: analysis_end in class TypeScriptPEGTLAnalyzer at line 225
    📝 Line content: '        auto analysis_end = std::chrono::high_resolution_clock::now();'
📄 Line 226 (in_class=1, brace_depth=2):         auto analysis_duration = std::chrono::duration_cast<std::chrono::milliseconds>(analysis_end - analysis_start).count();
🎯 Found member variable: analysis_duration in class TypeScriptPEGTLAnalyzer at line 226
    📝 Line content: '        auto analysis_duration = std::chrono::duration_cast<std::chrono::milliseconds>(analysis_end - analysis_start).count();'
📄 Line 227 (in_class=1, brace_depth=2):         std::cerr << "✅ 第1段階完了: " << processed_lines 
📄 Line 228 (in_class=1, brace_depth=2):                   << "行処理 (" << analysis_duration << "ms)" << std::endl;
📄 Line 229 (in_class=1, brace_depth=2):         
📄 Line 230 (in_class=1, brace_depth=2):         // 🚀 【JavaScript逆輸入】高速モードではネスト掘削スキップ！
📄 Line 231 (in_class=1, brace_depth=2):         if (use_high_speed_mode) {
📄 Line 232 (in_class=1, brace_depth=3):             std::cerr << "⚡ 高速モード: ネスト掘削スキップ（JavaScript戦略移植）" << std::endl;
📄 Line 233 (in_class=1, brace_depth=3):             std::cerr << "\n📊 処理戦略: 大規模TSファイルモード（基本検出のみ）" << std::endl;
📄 Line 234 (in_class=1, brace_depth=3):         } else {
📄 Line 235 (in_class=1, brace_depth=3):             // 第2段階: 二重正規表現アタック！クラス全体を捕獲してメソッド検出
📄 Line 236 (in_class=1, brace_depth=3):             std::cerr << "🎯 二重正規表現アタック開始！" << std::endl;
📄 Line 237 (in_class=1, brace_depth=3):             double_regex_attack_for_class_methods(content, result, existing_functions);
📄 Line 238 (in_class=1, brace_depth=3):             
📄 Line 239 (in_class=1, brace_depth=3):             // 🚀 第3段階: 【ユーザー天才アイデア】無限ネスト掘削アタック！
📄 Line 240 (in_class=1, brace_depth=3):             if (use_full_analysis || use_sampling_mode) {
📄 Line 241 (in_class=1, brace_depth=4):                 infinite_nested_function_attack(content, result, existing_functions);
📄 Line 242 (in_class=1, brace_depth=4):             }
📄 Line 243 (in_class=1, brace_depth=3):         }
📄 Line 244 (in_class=1, brace_depth=2):     }
📄 Line 245 (in_class=1, brace_depth=1):     
📄 Line 246 (in_class=1, brace_depth=1):     // TypeScript関数パターンの抽出
📄 Line 247 (in_class=1, brace_depth=1):     void extract_typescript_functions_from_line(const std::string& line, size_t line_number,
📄 Line 248 (in_class=1, brace_depth=1):                                                 AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 249 (in_class=1, brace_depth=2):         
📄 Line 250 (in_class=1, brace_depth=2):         // パターン1: export function name<T>(
📄 Line 251 (in_class=1, brace_depth=2):         std::regex export_function_pattern(R"(^\s*export\s+function\s+(\w+)(?:<[^>]*>)?\s*\()");
📄 Line 252 (in_class=1, brace_depth=2):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 252
    📝 Line content: '        std::smatch match;'
📄 Line 253 (in_class=1, brace_depth=2):         
📄 Line 254 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, export_function_pattern)) {
📄 Line 255 (in_class=1, brace_depth=3):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class TypeScriptPEGTLAnalyzer at line 255
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 256 (in_class=1, brace_depth=3):             if (existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 257 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 257
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 258 (in_class=1, brace_depth=4):                 func_info.name = func_name;
📄 Line 259 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 260 (in_class=1, brace_depth=4):                 // func_info.is_exported = true;
📄 Line 261 (in_class=1, brace_depth=4):                 // func_info.is_typescript_detected = true;
📄 Line 262 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 263 (in_class=1, brace_depth=4):                 existing_functions.insert(func_name);
📄 Line 264 (in_class=1, brace_depth=4):             }
📄 Line 265 (in_class=1, brace_depth=3):         }
📄 Line 266 (in_class=1, brace_depth=2):         
📄 Line 267 (in_class=1, brace_depth=2):         // パターン2: export const name = (
📄 Line 268 (in_class=1, brace_depth=2):         std::regex export_const_pattern(R"(^\s*export\s+const\s+(\w+)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>)");
📄 Line 269 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, export_const_pattern)) {
📄 Line 270 (in_class=1, brace_depth=3):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class TypeScriptPEGTLAnalyzer at line 270
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 271 (in_class=1, brace_depth=3):             if (existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 272 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 272
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 273 (in_class=1, brace_depth=4):                 func_info.name = func_name;
📄 Line 274 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 275 (in_class=1, brace_depth=4):                 func_info.is_arrow_function = true;
📄 Line 276 (in_class=1, brace_depth=4):                 // func_info.is_exported = true;
📄 Line 277 (in_class=1, brace_depth=4):                 // func_info.is_typescript_detected = true;
📄 Line 278 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 279 (in_class=1, brace_depth=4):                 existing_functions.insert(func_name);
📄 Line 280 (in_class=1, brace_depth=4):             }
📄 Line 281 (in_class=1, brace_depth=3):         }
📄 Line 282 (in_class=1, brace_depth=2):         
📄 Line 283 (in_class=1, brace_depth=2):         // パターン3: export async function name(
📄 Line 284 (in_class=1, brace_depth=2):         std::regex export_async_pattern(R"(^\s*export\s+async\s+function\s+(\w+)(?:<[^>]*>)?\s*\()");
📄 Line 285 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, export_async_pattern)) {
📄 Line 286 (in_class=1, brace_depth=3):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class TypeScriptPEGTLAnalyzer at line 286
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 287 (in_class=1, brace_depth=3):             if (existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 288 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 288
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 289 (in_class=1, brace_depth=4):                 func_info.name = func_name;
📄 Line 290 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 291 (in_class=1, brace_depth=4):                 func_info.is_async = true;
📄 Line 292 (in_class=1, brace_depth=4):                 // func_info.is_exported = true;
📄 Line 293 (in_class=1, brace_depth=4):                 // func_info.is_typescript_detected = true;
📄 Line 294 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 295 (in_class=1, brace_depth=4):                 existing_functions.insert(func_name);
📄 Line 296 (in_class=1, brace_depth=4):             }
📄 Line 297 (in_class=1, brace_depth=3):         }
📄 Line 298 (in_class=1, brace_depth=2):     }
📄 Line 299 (in_class=1, brace_depth=1):     
📄 Line 300 (in_class=1, brace_depth=1):     // TypeScriptクラスパターンの抽出
📄 Line 301 (in_class=1, brace_depth=1):     void extract_typescript_classes_from_line(const std::string& line, size_t line_number,
📄 Line 302 (in_class=1, brace_depth=1):                                              AnalysisResult& result, std::set<std::string>& existing_classes) {
📄 Line 303 (in_class=1, brace_depth=2):         
📄 Line 304 (in_class=1, brace_depth=2):         // パターン1: export class Name
📄 Line 305 (in_class=1, brace_depth=2):         std::regex export_class_pattern(R"(^\s*export\s+(?:default\s+)?(?:abstract\s+)?class\s+(\w+))");
📄 Line 306 (in_class=1, brace_depth=2):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 306
    📝 Line content: '        std::smatch match;'
📄 Line 307 (in_class=1, brace_depth=2):         
📄 Line 308 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, export_class_pattern)) {
📄 Line 309 (in_class=1, brace_depth=3):             std::string class_name = match[1].str();
🎯 Found member variable: class_name in class TypeScriptPEGTLAnalyzer at line 309
    📝 Line content: '            std::string class_name = match[1].str();'
📄 Line 310 (in_class=1, brace_depth=3):             if (existing_classes.find(class_name) == existing_classes.end()) {
📄 Line 311 (in_class=1, brace_depth=4):                 ClassInfo class_info;
🎯 Found member variable: class_info in class TypeScriptPEGTLAnalyzer at line 311
    📝 Line content: '                ClassInfo class_info;'
📄 Line 312 (in_class=1, brace_depth=4):                 class_info.name = class_name;
📄 Line 313 (in_class=1, brace_depth=4):                 class_info.start_line = line_number;
📄 Line 314 (in_class=1, brace_depth=4):                 result.classes.push_back(class_info);
📄 Line 315 (in_class=1, brace_depth=4):                 existing_classes.insert(class_name);
📄 Line 316 (in_class=1, brace_depth=4):             }
📄 Line 317 (in_class=1, brace_depth=3):         }
📄 Line 318 (in_class=1, brace_depth=2):         
📄 Line 319 (in_class=1, brace_depth=2):         // パターン2: class Name (exportなし)
📄 Line 320 (in_class=1, brace_depth=2):         std::regex class_pattern(R"(^\s*(?:abstract\s+)?class\s+(\w+))");
📄 Line 321 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, class_pattern)) {
📄 Line 322 (in_class=1, brace_depth=3):             std::string class_name = match[1].str();
🎯 Found member variable: class_name in class TypeScriptPEGTLAnalyzer at line 322
    📝 Line content: '            std::string class_name = match[1].str();'
📄 Line 323 (in_class=1, brace_depth=3):             if (existing_classes.find(class_name) == existing_classes.end()) {
📄 Line 324 (in_class=1, brace_depth=4):                 ClassInfo class_info;
🎯 Found member variable: class_info in class TypeScriptPEGTLAnalyzer at line 324
    📝 Line content: '                ClassInfo class_info;'
📄 Line 325 (in_class=1, brace_depth=4):                 class_info.name = class_name;
📄 Line 326 (in_class=1, brace_depth=4):                 class_info.start_line = line_number;
📄 Line 327 (in_class=1, brace_depth=4):                 result.classes.push_back(class_info);
📄 Line 328 (in_class=1, brace_depth=4):                 existing_classes.insert(class_name);
📄 Line 329 (in_class=1, brace_depth=4):             }
📄 Line 330 (in_class=1, brace_depth=3):         }
📄 Line 331 (in_class=1, brace_depth=2):     }
📄 Line 332 (in_class=1, brace_depth=1):     
📄 Line 333 (in_class=1, brace_depth=1):     // TypeScriptインターフェースパターンの抽出
📄 Line 334 (in_class=1, brace_depth=1):     void extract_typescript_interfaces_from_line(const std::string& line, size_t line_number,
📄 Line 335 (in_class=1, brace_depth=1):                                                 AnalysisResult& result, std::set<std::string>& existing_classes) {
📄 Line 336 (in_class=1, brace_depth=2):         
📄 Line 337 (in_class=1, brace_depth=2):         // interface Name をクラスとして扱う（統計用）
📄 Line 338 (in_class=1, brace_depth=2):         std::regex interface_pattern(R"(^\s*(?:export\s+)?interface\s+(\w+))");
📄 Line 339 (in_class=1, brace_depth=2):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 339
    📝 Line content: '        std::smatch match;'
📄 Line 340 (in_class=1, brace_depth=2):         
📄 Line 341 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, interface_pattern)) {
📄 Line 342 (in_class=1, brace_depth=3):             std::string interface_name = match[1].str();
🎯 Found member variable: interface_name in class TypeScriptPEGTLAnalyzer at line 342
    📝 Line content: '            std::string interface_name = match[1].str();'
📄 Line 343 (in_class=1, brace_depth=3):             if (existing_classes.find(interface_name) == existing_classes.end()) {
📄 Line 344 (in_class=1, brace_depth=4):                 ClassInfo interface_info;
🎯 Found member variable: interface_info in class TypeScriptPEGTLAnalyzer at line 344
    📝 Line content: '                ClassInfo interface_info;'
📄 Line 345 (in_class=1, brace_depth=4):                 interface_info.name = "interface:" + interface_name;
📄 Line 346 (in_class=1, brace_depth=4):                 interface_info.start_line = line_number;
📄 Line 347 (in_class=1, brace_depth=4):                 result.classes.push_back(interface_info);
📄 Line 348 (in_class=1, brace_depth=4):                 existing_classes.insert(interface_name);
📄 Line 349 (in_class=1, brace_depth=4):             }
📄 Line 350 (in_class=1, brace_depth=3):         }
📄 Line 351 (in_class=1, brace_depth=2):         
📄 Line 352 (in_class=1, brace_depth=2):         // type alias もクラスとして扱う
📄 Line 353 (in_class=1, brace_depth=2):         std::regex type_pattern(R"(^\s*(?:export\s+)?type\s+(\w+))");
📄 Line 354 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, type_pattern)) {
📄 Line 355 (in_class=1, brace_depth=3):             std::string type_name = match[1].str();
🎯 Found member variable: type_name in class TypeScriptPEGTLAnalyzer at line 355
    📝 Line content: '            std::string type_name = match[1].str();'
📄 Line 356 (in_class=1, brace_depth=3):             if (existing_classes.find(type_name) == existing_classes.end()) {
📄 Line 357 (in_class=1, brace_depth=4):                 ClassInfo type_info;
🎯 Found member variable: type_info in class TypeScriptPEGTLAnalyzer at line 357
    📝 Line content: '                ClassInfo type_info;'
📄 Line 358 (in_class=1, brace_depth=4):                 type_info.name = "type:" + type_name;
📄 Line 359 (in_class=1, brace_depth=4):                 type_info.start_line = line_number;
📄 Line 360 (in_class=1, brace_depth=4):                 result.classes.push_back(type_info);
📄 Line 361 (in_class=1, brace_depth=4):                 existing_classes.insert(type_name);
📄 Line 362 (in_class=1, brace_depth=4):             }
📄 Line 363 (in_class=1, brace_depth=3):         }
📄 Line 364 (in_class=1, brace_depth=2):     }
📄 Line 365 (in_class=1, brace_depth=1):     
📄 Line 366 (in_class=1, brace_depth=1):     // TypeScriptメソッドパターンの抽出
📄 Line 367 (in_class=1, brace_depth=1):     void extract_typescript_methods_from_line(const std::string& line, size_t line_number,
📄 Line 368 (in_class=1, brace_depth=1):                                              AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 369 (in_class=1, brace_depth=2):         
📄 Line 370 (in_class=1, brace_depth=2):         // パターン1: async methodName(
📄 Line 371 (in_class=1, brace_depth=2):         std::regex async_method_pattern(R"(^\s*(?:private\s+|public\s+|protected\s+)?async\s+(\w+)\s*\()");
📄 Line 372 (in_class=1, brace_depth=2):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 372
    📝 Line content: '        std::smatch match;'
📄 Line 373 (in_class=1, brace_depth=2):         
📄 Line 374 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, async_method_pattern)) {
📄 Line 375 (in_class=1, brace_depth=3):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class TypeScriptPEGTLAnalyzer at line 375
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 376 (in_class=1, brace_depth=3):             if (existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 377 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 377
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 378 (in_class=1, brace_depth=4):                 func_info.name = method_name;
📄 Line 379 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 380 (in_class=1, brace_depth=4):                 func_info.is_async = true;
📄 Line 381 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 382 (in_class=1, brace_depth=4):                 existing_functions.insert(method_name);
📄 Line 383 (in_class=1, brace_depth=4):             }
📄 Line 384 (in_class=1, brace_depth=3):         }
📄 Line 385 (in_class=1, brace_depth=2):         
📄 Line 386 (in_class=1, brace_depth=2):         // パターン2: methodName(params): ReturnType
📄 Line 387 (in_class=1, brace_depth=2):         std::regex method_pattern(R"(^\s*(?:private\s+|public\s+|protected\s+)?(\w+)\s*\([^)]*\)\s*:\s*\w)");
📄 Line 388 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, method_pattern)) {
📄 Line 389 (in_class=1, brace_depth=3):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class TypeScriptPEGTLAnalyzer at line 389
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 390 (in_class=1, brace_depth=3):             if (existing_functions.find(method_name) == existing_functions.end() && 
📄 Line 391 (in_class=1, brace_depth=3):                 method_name != "constructor") {
📄 Line 392 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 392
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 393 (in_class=1, brace_depth=4):                 func_info.name = method_name;
📄 Line 394 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 395 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 396 (in_class=1, brace_depth=4):                 existing_functions.insert(method_name);
📄 Line 397 (in_class=1, brace_depth=4):             }
📄 Line 398 (in_class=1, brace_depth=3):         }
📄 Line 399 (in_class=1, brace_depth=2):         
📄 Line 400 (in_class=1, brace_depth=2):         // パターン3: interface内のメソッド定義 methodName(params): ReturnType;
📄 Line 401 (in_class=1, brace_depth=2):         std::regex interface_method_pattern(R"(^\s*(\w+)\s*\([^)]*\)\s*:\s*[^;]+;)");
📄 Line 402 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, interface_method_pattern)) {
📄 Line 403 (in_class=1, brace_depth=3):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class TypeScriptPEGTLAnalyzer at line 403
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 404 (in_class=1, brace_depth=3):             if (existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 405 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 405
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 406 (in_class=1, brace_depth=4):                 func_info.name = method_name;
📄 Line 407 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 408 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 409 (in_class=1, brace_depth=4):                 existing_functions.insert(method_name);
📄 Line 410 (in_class=1, brace_depth=4):             }
📄 Line 411 (in_class=1, brace_depth=3):         }
📄 Line 412 (in_class=1, brace_depth=2):         
📄 Line 413 (in_class=1, brace_depth=2):         // パターン4: getter/setter
📄 Line 414 (in_class=1, brace_depth=2):         std::regex getter_setter_pattern(R"(^\s*(?:get|set)\s+(\w+)\s*\()");
📄 Line 415 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, getter_setter_pattern)) {
📄 Line 416 (in_class=1, brace_depth=3):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class TypeScriptPEGTLAnalyzer at line 416
    📝 Line content: '            std::string prop_name = match[1].str();'
📄 Line 417 (in_class=1, brace_depth=3):             std::string accessor_name = "get_" + prop_name;  // or set_
🎯 Found member variable: accessor_name in class TypeScriptPEGTLAnalyzer at line 417
    📝 Line content: '            std::string accessor_name = "get_" + prop_name;  // or set_'
📄 Line 418 (in_class=1, brace_depth=3):             if (existing_functions.find(accessor_name) == existing_functions.end()) {
📄 Line 419 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 419
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 420 (in_class=1, brace_depth=4):                 func_info.name = accessor_name;
📄 Line 421 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 422 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 423 (in_class=1, brace_depth=4):                 existing_functions.insert(accessor_name);
📄 Line 424 (in_class=1, brace_depth=4):             }
📄 Line 425 (in_class=1, brace_depth=3):         }
📄 Line 426 (in_class=1, brace_depth=2):         
📄 Line 427 (in_class=1, brace_depth=2):         // パターン5: constructor
📄 Line 428 (in_class=1, brace_depth=2):         std::regex constructor_pattern(R"(^\s*constructor\s*\()");
📄 Line 429 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, constructor_pattern)) {
📄 Line 430 (in_class=1, brace_depth=3):             if (existing_functions.find("constructor") == existing_functions.end()) {
📄 Line 431 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 431
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 432 (in_class=1, brace_depth=4):                 func_info.name = "constructor";
📄 Line 433 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 434 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 435 (in_class=1, brace_depth=4):                 existing_functions.insert("constructor");
📄 Line 436 (in_class=1, brace_depth=4):             }
📄 Line 437 (in_class=1, brace_depth=3):         }
📄 Line 438 (in_class=1, brace_depth=2):         
📄 Line 439 (in_class=1, brace_depth=2):         // パターン6: async *[Symbol.asyncIterator]()
📄 Line 440 (in_class=1, brace_depth=2):         std::regex async_iterator_pattern(R"(^\s*async\s*\*\s*\[Symbol\.asyncIterator\]\s*\(\))");
📄 Line 441 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, async_iterator_pattern)) {
📄 Line 442 (in_class=1, brace_depth=3):             if (existing_functions.find("[Symbol.asyncIterator]") == existing_functions.end()) {
📄 Line 443 (in_class=1, brace_depth=4):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 443
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 444 (in_class=1, brace_depth=4):                 func_info.name = "[Symbol.asyncIterator]";
📄 Line 445 (in_class=1, brace_depth=4):                 func_info.start_line = line_number;
📄 Line 446 (in_class=1, brace_depth=4):                 func_info.is_async = true;
📄 Line 447 (in_class=1, brace_depth=4):                 result.functions.push_back(func_info);
📄 Line 448 (in_class=1, brace_depth=4):                 existing_functions.insert("[Symbol.asyncIterator]");
📄 Line 449 (in_class=1, brace_depth=4):             }
📄 Line 450 (in_class=1, brace_depth=3):         }
📄 Line 451 (in_class=1, brace_depth=2):     }
📄 Line 452 (in_class=1, brace_depth=1):     
📄 Line 453 (in_class=1, brace_depth=1):     // 🎯 二重正規表現アタック！クラス内メソッド検出の真の力
📄 Line 454 (in_class=1, brace_depth=1):     void double_regex_attack_for_class_methods(const std::string& content, AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 455 (in_class=1, brace_depth=2):         
📄 Line 456 (in_class=1, brace_depth=2):         // 第1段階：クラス全体を探知・捕獲
📄 Line 457 (in_class=1, brace_depth=2):         std::regex class_declaration_pattern(R"((?:export\s+)?class\s+(\w+)[^{]*\{)");
📄 Line 458 (in_class=1, brace_depth=4):         std::sregex_iterator class_iter(content.begin(), content.end(), class_declaration_pattern);
📄 Line 459 (in_class=1, brace_depth=4):         std::sregex_iterator class_end;
🎯 Found member variable: class_end in class TypeScriptPEGTLAnalyzer at line 459
    📝 Line content: '        std::sregex_iterator class_end;'
📄 Line 460 (in_class=1, brace_depth=4):         
📄 Line 461 (in_class=1, brace_depth=4):         for (; class_iter != class_end; ++class_iter) {
📄 Line 462 (in_class=1, brace_depth=5):             const std::smatch& class_match = *class_iter;
🎯 Found member variable: class_match in class TypeScriptPEGTLAnalyzer at line 462
    📝 Line content: '            const std::smatch& class_match = *class_iter;'
📄 Line 463 (in_class=1, brace_depth=5):             std::string class_name = class_match[1].str();
🎯 Found member variable: class_name in class TypeScriptPEGTLAnalyzer at line 463
    📝 Line content: '            std::string class_name = class_match[1].str();'
📄 Line 464 (in_class=1, brace_depth=5):             size_t class_start_pos = class_match.position() + class_match.length() - 1; // '{' の位置
🎯 Found member variable: class_start_pos in class TypeScriptPEGTLAnalyzer at line 464
    📝 Line content: '            size_t class_start_pos = class_match.position() + class_match.length() - 1; // '{' の位置'
📄 Line 465 (in_class=1, brace_depth=6):             
📄 Line 466 (in_class=1, brace_depth=6):             std::cerr << "🎯 クラス捕獲: " << class_name << " at position " << class_start_pos << std::endl;
📄 Line 467 (in_class=1, brace_depth=6):             
📄 Line 468 (in_class=1, brace_depth=6):             // クラス内容を中括弧バランスで抽出
📄 Line 469 (in_class=1, brace_depth=6):             std::string class_content = extract_balanced_braces_content(content, class_start_pos);
🎯 Found member variable: class_content in class TypeScriptPEGTLAnalyzer at line 469
    📝 Line content: '            std::string class_content = extract_balanced_braces_content(content, class_start_pos);'
📄 Line 470 (in_class=1, brace_depth=6):             
📄 Line 471 (in_class=1, brace_depth=6):             if (!class_content.empty()) {
📄 Line 472 (in_class=1, brace_depth=7):                 std::cerr << "📦 クラス内容長: " << class_content.length() << " bytes" << std::endl;
📄 Line 473 (in_class=1, brace_depth=7):                 
📄 Line 474 (in_class=1, brace_depth=7):                 // 第2段階：クラス内容に集中メソッド検出アタック！
📄 Line 475 (in_class=1, brace_depth=7):                 second_stage_method_attack(class_content, result, existing_functions, class_start_pos);
📄 Line 476 (in_class=1, brace_depth=7):             }
📄 Line 477 (in_class=1, brace_depth=6):         }
📄 Line 478 (in_class=1, brace_depth=5):     }
📄 Line 479 (in_class=1, brace_depth=4):     
📄 Line 480 (in_class=1, brace_depth=4):     // 中括弧バランス取りながらクラス内容抽出
📄 Line 481 (in_class=1, brace_depth=4):     std::string extract_balanced_braces_content(const std::string& content, size_t start_pos) {
📄 Line 482 (in_class=1, brace_depth=5):         if (start_pos >= content.length() || content[start_pos] != '{') {
📄 Line 483 (in_class=1, brace_depth=7):             return "";
📄 Line 484 (in_class=1, brace_depth=7):         }
📄 Line 485 (in_class=1, brace_depth=6):         
📄 Line 486 (in_class=1, brace_depth=6):         int brace_count = 1;
🎯 Found member variable: brace_count in class TypeScriptPEGTLAnalyzer at line 486
    📝 Line content: '        int brace_count = 1;'
📄 Line 487 (in_class=1, brace_depth=6):         size_t pos = start_pos + 1;
🎯 Found member variable: pos in class TypeScriptPEGTLAnalyzer at line 487
    📝 Line content: '        size_t pos = start_pos + 1;'
📄 Line 488 (in_class=1, brace_depth=6):         
📄 Line 489 (in_class=1, brace_depth=6):         while (pos < content.length() && brace_count > 0) {
📄 Line 490 (in_class=1, brace_depth=7):             if (content[pos] == '{') {
📄 Line 491 (in_class=1, brace_depth=9):                 brace_count++;
📄 Line 492 (in_class=1, brace_depth=9):             } else if (content[pos] == '}') {
📄 Line 493 (in_class=1, brace_depth=8):                 brace_count--;
📄 Line 494 (in_class=1, brace_depth=8):             }
📄 Line 495 (in_class=1, brace_depth=7):             pos++;
📄 Line 496 (in_class=1, brace_depth=7):         }
📄 Line 497 (in_class=1, brace_depth=6):         
📄 Line 498 (in_class=1, brace_depth=6):         if (brace_count == 0) {
📄 Line 499 (in_class=1, brace_depth=7):             return content.substr(start_pos + 1, pos - start_pos - 2); // 中括弧を除外
📄 Line 500 (in_class=1, brace_depth=7):         }
📄 Line 501 (in_class=1, brace_depth=6):         return "";
📄 Line 502 (in_class=1, brace_depth=6):     }
📄 Line 503 (in_class=1, brace_depth=5):     
📄 Line 504 (in_class=1, brace_depth=5):     // 🎯 三重正規表現アタック：第2・第3段階
📄 Line 505 (in_class=1, brace_depth=5):     void second_stage_method_attack(const std::string& class_content, AnalysisResult& result, 
📄 Line 506 (in_class=1, brace_depth=5):                                    std::set<std::string>& existing_functions, size_t class_start_pos) {
📄 Line 507 (in_class=1, brace_depth=6):         
📄 Line 508 (in_class=1, brace_depth=6):         std::cerr << "🔥 三重正規表現アタック第2段階開始！" << std::endl;
📄 Line 509 (in_class=1, brace_depth=6):         
📄 Line 510 (in_class=1, brace_depth=6):         // 第2段階：基本形抽出（にゃーのアイデア）- シンプルな正規表現
📄 Line 511 (in_class=1, brace_depth=6):         std::regex basic_method_pattern(R"((\w+)\s*\([^)]*\)\s*(?::\s*[^{]+)?\s*\{)");
📄 Line 512 (in_class=1, brace_depth=8):         std::sregex_iterator method_iter(class_content.begin(), class_content.end(), basic_method_pattern);
📄 Line 513 (in_class=1, brace_depth=8):         std::sregex_iterator method_end;
🎯 Found member variable: method_end in class TypeScriptPEGTLAnalyzer at line 513
    📝 Line content: '        std::sregex_iterator method_end;'
📄 Line 514 (in_class=1, brace_depth=8):         
📄 Line 515 (in_class=1, brace_depth=8):         int method_count = 0;
🎯 Found member variable: method_count in class TypeScriptPEGTLAnalyzer at line 515
    📝 Line content: '        int method_count = 0;'
📄 Line 516 (in_class=1, brace_depth=8):         for (; method_iter != method_end; ++method_iter) {
📄 Line 517 (in_class=1, brace_depth=9):             const std::smatch& method_match = *method_iter;
🎯 Found member variable: method_match in class TypeScriptPEGTLAnalyzer at line 517
    📝 Line content: '            const std::smatch& method_match = *method_iter;'
📄 Line 518 (in_class=1, brace_depth=9):             std::string method_name = method_match[1].str();
🎯 Found member variable: method_name in class TypeScriptPEGTLAnalyzer at line 518
    📝 Line content: '            std::string method_name = method_match[1].str();'
📄 Line 519 (in_class=1, brace_depth=9):             
📄 Line 520 (in_class=1, brace_depth=9):             // 制御フロー文を除外
📄 Line 521 (in_class=1, brace_depth=9):             if (method_name == "if" || method_name == "for" || method_name == "while" || 
📄 Line 522 (in_class=1, brace_depth=9):                 method_name == "switch" || method_name == "try" || method_name == "catch" ||
📄 Line 523 (in_class=1, brace_depth=9):                 method_name == "else" || method_name == "return") {
📄 Line 524 (in_class=1, brace_depth=10):                 std::cerr << "🚫 制御フロー文除外: " << method_name << std::endl;
📄 Line 525 (in_class=1, brace_depth=10):                 continue;
📄 Line 526 (in_class=1, brace_depth=10):             }
📄 Line 527 (in_class=1, brace_depth=9):             
📄 Line 528 (in_class=1, brace_depth=9):             if (existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 529 (in_class=1, brace_depth=10):                 std::cerr << "🎯 第2段階基本形抽出成功: " << method_name << std::endl;
📄 Line 530 (in_class=1, brace_depth=10):                 
📄 Line 531 (in_class=1, brace_depth=10):                 // 第3段階：詳細情報狙い撃ち（にゃーのアイデア）
📄 Line 532 (in_class=1, brace_depth=10):                 FunctionInfo func_info = triple_regex_attack_for_details(class_content, method_match, method_name);
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 532
    📝 Line content: '                FunctionInfo func_info = triple_regex_attack_for_details(class_content, method_match, method_name);'
📄 Line 533 (in_class=1, brace_depth=10):                 
📄 Line 534 (in_class=1, brace_depth=10):                 result.functions.push_back(func_info);
📄 Line 535 (in_class=1, brace_depth=10):                 existing_functions.insert(method_name);
📄 Line 536 (in_class=1, brace_depth=10):                 method_count++;
📄 Line 537 (in_class=1, brace_depth=10):             }
📄 Line 538 (in_class=1, brace_depth=9):         }
📄 Line 539 (in_class=1, brace_depth=8):         
📄 Line 540 (in_class=1, brace_depth=8):         std::cerr << "🎯 三重攻撃完了: " << method_count << "個のメソッドを高精度検出" << std::endl;
📄 Line 541 (in_class=1, brace_depth=8):     }
📄 Line 542 (in_class=1, brace_depth=7):     
📄 Line 543 (in_class=1, brace_depth=7):     // 🎯 第3段階：詳細情報狙い撃ち（にゃーのアイデア）
📄 Line 544 (in_class=1, brace_depth=7):     FunctionInfo triple_regex_attack_for_details(const std::string& class_content, 
📄 Line 545 (in_class=1, brace_depth=7):                                                 const std::smatch& method_match,
📄 Line 546 (in_class=1, brace_depth=7):                                                 const std::string& method_name) {
📄 Line 547 (in_class=1, brace_depth=8):         FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 547
    📝 Line content: '        FunctionInfo func_info;'
📄 Line 548 (in_class=1, brace_depth=8):         func_info.name = method_name;
📄 Line 549 (in_class=1, brace_depth=8):         func_info.start_line = calculate_line_number(class_content, method_match.position());
📄 Line 550 (in_class=1, brace_depth=8):         
📄 Line 551 (in_class=1, brace_depth=8):         std::cerr << "💥 第3段階開始: " << method_name << " の詳細情報を狙い撃ち" << std::endl;
📄 Line 552 (in_class=1, brace_depth=8):         
📄 Line 553 (in_class=1, brace_depth=8):         // マッチした位置の行を抽出
📄 Line 554 (in_class=1, brace_depth=8):         std::string matched_line = extract_line_from_position(class_content, method_match.position());
🎯 Found member variable: matched_line in class TypeScriptPEGTLAnalyzer at line 554
    📝 Line content: '        std::string matched_line = extract_line_from_position(class_content, method_match.position());'
📄 Line 555 (in_class=1, brace_depth=8):         std::cerr << "🎯 攻撃対象行: " << matched_line.substr(0, 100) << "..." << std::endl;
📄 Line 556 (in_class=1, brace_depth=8):         
📄 Line 557 (in_class=1, brace_depth=8):         // 第3段階：同一行に対して複数の正規表現攻撃！
📄 Line 558 (in_class=1, brace_depth=8):         
📄 Line 559 (in_class=1, brace_depth=8):         // ⚡ async攻撃
📄 Line 560 (in_class=1, brace_depth=8):         if (std::regex_search(matched_line, std::regex(R"(async\s+)"))) {
📄 Line 561 (in_class=1, brace_depth=9):             func_info.is_async = true;
📄 Line 562 (in_class=1, brace_depth=9):             std::cerr << "⚡ async検出成功！" << std::endl;
📄 Line 563 (in_class=1, brace_depth=9):         }
📄 Line 564 (in_class=1, brace_depth=8):         
📄 Line 565 (in_class=1, brace_depth=8):         // 🔒 private攻撃
📄 Line 566 (in_class=1, brace_depth=8):         bool is_private = std::regex_search(matched_line, std::regex(R"(private\s+)"));
🎯 Found member variable: is_private in class TypeScriptPEGTLAnalyzer at line 566
    📝 Line content: '        bool is_private = std::regex_search(matched_line, std::regex(R"(private\s+)"));'
📄 Line 567 (in_class=1, brace_depth=8):         if (is_private) {
📄 Line 568 (in_class=1, brace_depth=9):             std::cerr << "🔒 private検出成功！" << std::endl;
📄 Line 569 (in_class=1, brace_depth=9):         }
📄 Line 570 (in_class=1, brace_depth=8):         
📄 Line 571 (in_class=1, brace_depth=8):         // 🌍 public攻撃
📄 Line 572 (in_class=1, brace_depth=8):         bool is_public = std::regex_search(matched_line, std::regex(R"(public\s+)"));
🎯 Found member variable: is_public in class TypeScriptPEGTLAnalyzer at line 572
    📝 Line content: '        bool is_public = std::regex_search(matched_line, std::regex(R"(public\s+)"));'
📄 Line 573 (in_class=1, brace_depth=8):         if (is_public) {
📄 Line 574 (in_class=1, brace_depth=9):             std::cerr << "🌍 public検出成功！" << std::endl;
📄 Line 575 (in_class=1, brace_depth=9):         }
📄 Line 576 (in_class=1, brace_depth=8):         
📄 Line 577 (in_class=1, brace_depth=8):         // 🛡️ protected攻撃
📄 Line 578 (in_class=1, brace_depth=8):         bool is_protected = std::regex_search(matched_line, std::regex(R"(protected\s+)"));
🎯 Found member variable: is_protected in class TypeScriptPEGTLAnalyzer at line 578
    📝 Line content: '        bool is_protected = std::regex_search(matched_line, std::regex(R"(protected\s+)"));'
📄 Line 579 (in_class=1, brace_depth=8):         if (is_protected) {
📄 Line 580 (in_class=1, brace_depth=9):             std::cerr << "🛡️ protected検出成功！" << std::endl;
📄 Line 581 (in_class=1, brace_depth=9):         }
📄 Line 582 (in_class=1, brace_depth=8):             
📄 Line 583 (in_class=1, brace_depth=8):         // 🏗️ static攻撃
📄 Line 584 (in_class=1, brace_depth=8):         bool is_static = std::regex_search(matched_line, std::regex(R"(static\s+)"));
🎯 Found member variable: is_static in class TypeScriptPEGTLAnalyzer at line 584
    📝 Line content: '        bool is_static = std::regex_search(matched_line, std::regex(R"(static\s+)"));'
📄 Line 585 (in_class=1, brace_depth=8):         if (is_static) {
📄 Line 586 (in_class=1, brace_depth=9):             std::cerr << "🏗️ static検出成功！" << std::endl;
📄 Line 587 (in_class=1, brace_depth=9):         }
📄 Line 588 (in_class=1, brace_depth=8):         
📄 Line 589 (in_class=1, brace_depth=8):         // 📖 readonly攻撃
📄 Line 590 (in_class=1, brace_depth=8):         bool is_readonly = std::regex_search(matched_line, std::regex(R"(readonly\s+)"));
🎯 Found member variable: is_readonly in class TypeScriptPEGTLAnalyzer at line 590
    📝 Line content: '        bool is_readonly = std::regex_search(matched_line, std::regex(R"(readonly\s+)"));'
📄 Line 591 (in_class=1, brace_depth=8):         if (is_readonly) {
📄 Line 592 (in_class=1, brace_depth=9):             std::cerr << "📖 readonly検出成功！" << std::endl;
📄 Line 593 (in_class=1, brace_depth=9):         }
📄 Line 594 (in_class=1, brace_depth=8):         
📄 Line 595 (in_class=1, brace_depth=8):         // 🎯 戻り値型攻撃
📄 Line 596 (in_class=1, brace_depth=8):         std::regex return_type_pattern(R"(:\s*([^{]+)\s*\{)");
📄 Line 597 (in_class=1, brace_depth=10):         std::smatch return_match;
🎯 Found member variable: return_match in class TypeScriptPEGTLAnalyzer at line 597
    📝 Line content: '        std::smatch return_match;'
📄 Line 598 (in_class=1, brace_depth=10):         if (std::regex_search(matched_line, return_match, return_type_pattern)) {
📄 Line 599 (in_class=1, brace_depth=11):             std::string return_type = trim_whitespace(return_match[1].str());
🎯 Found member variable: return_type in class TypeScriptPEGTLAnalyzer at line 599
    📝 Line content: '            std::string return_type = trim_whitespace(return_match[1].str());'
📄 Line 600 (in_class=1, brace_depth=11):             std::cerr << "🎯 戻り値型検出: " << return_type << std::endl;
📄 Line 601 (in_class=1, brace_depth=11):         }
📄 Line 602 (in_class=1, brace_depth=10):         
📄 Line 603 (in_class=1, brace_depth=10):         // 🧬 ジェネリクス攻撃
📄 Line 604 (in_class=1, brace_depth=10):         std::regex generic_pattern(method_name + R"(<([^>]+)>)");
📄 Line 605 (in_class=1, brace_depth=10):         std::smatch generic_match;
🎯 Found member variable: generic_match in class TypeScriptPEGTLAnalyzer at line 605
    📝 Line content: '        std::smatch generic_match;'
📄 Line 606 (in_class=1, brace_depth=10):         if (std::regex_search(matched_line, generic_match, generic_pattern)) {
📄 Line 607 (in_class=1, brace_depth=11):             std::string generic_params = generic_match[1].str();
🎯 Found member variable: generic_params in class TypeScriptPEGTLAnalyzer at line 607
    📝 Line content: '            std::string generic_params = generic_match[1].str();'
📄 Line 608 (in_class=1, brace_depth=11):             std::cerr << "🧬 ジェネリクス検出: <" << generic_params << ">" << std::endl;
📄 Line 609 (in_class=1, brace_depth=11):         }
📄 Line 610 (in_class=1, brace_depth=10):         
📄 Line 611 (in_class=1, brace_depth=10):         std::cerr << "💥 第3段階完了: " << method_name << " の詳細分析成功" << std::endl;
📄 Line 612 (in_class=1, brace_depth=10):         return func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 612
    📝 Line content: '        return func_info;'
📄 Line 613 (in_class=1, brace_depth=10):     }
📄 Line 614 (in_class=1, brace_depth=9):     
📄 Line 615 (in_class=1, brace_depth=9):     // マッチした位置から実際の行を抽出
📄 Line 616 (in_class=1, brace_depth=9):     std::string extract_line_from_position(const std::string& content, size_t pos) {
📄 Line 617 (in_class=1, brace_depth=10):         // 行の開始位置を探す
📄 Line 618 (in_class=1, brace_depth=10):         size_t line_start = content.rfind('\n', pos);
🎯 Found member variable: line_start in class TypeScriptPEGTLAnalyzer at line 618
    📝 Line content: '        size_t line_start = content.rfind('\n', pos);'
📄 Line 619 (in_class=1, brace_depth=10):         if (line_start == std::string::npos) {
📄 Line 620 (in_class=1, brace_depth=11):             line_start = 0;
📄 Line 621 (in_class=1, brace_depth=11):         } else {
📄 Line 622 (in_class=1, brace_depth=11):             line_start += 1; // \nの次から
📄 Line 623 (in_class=1, brace_depth=11):         }
📄 Line 624 (in_class=1, brace_depth=10):         
📄 Line 625 (in_class=1, brace_depth=10):         // 行の終了位置を探す
📄 Line 626 (in_class=1, brace_depth=10):         size_t line_end = content.find('\n', pos);
🎯 Found member variable: line_end in class TypeScriptPEGTLAnalyzer at line 626
    📝 Line content: '        size_t line_end = content.find('\n', pos);'
📄 Line 627 (in_class=1, brace_depth=10):         if (line_end == std::string::npos) {
📄 Line 628 (in_class=1, brace_depth=11):             line_end = content.length();
📄 Line 629 (in_class=1, brace_depth=11):         }
📄 Line 630 (in_class=1, brace_depth=10):         
📄 Line 631 (in_class=1, brace_depth=10):         return content.substr(line_start, line_end - line_start);
📄 Line 632 (in_class=1, brace_depth=10):     }
📄 Line 633 (in_class=1, brace_depth=9):     
📄 Line 634 (in_class=1, brace_depth=9):     
📄 Line 635 (in_class=1, brace_depth=9):     // 文字列内の位置から行番号を計算
📄 Line 636 (in_class=1, brace_depth=9):     size_t calculate_line_number(const std::string& content, size_t pos) {
📄 Line 637 (in_class=1, brace_depth=10):         return std::count(content.begin(), content.begin() + pos, '\n') + 1;
📄 Line 638 (in_class=1, brace_depth=10):     }
📄 Line 639 (in_class=1, brace_depth=9):     
📄 Line 640 (in_class=1, brace_depth=9):     // 🚀 にゃー先生天才アイデア：行レベル二重アタック！未検出メソッド攻略
📄 Line 641 (in_class=1, brace_depth=9):     void gemini_line_level_double_attack(const std::string& line, size_t line_number,
📄 Line 642 (in_class=1, brace_depth=9):                                         AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 643 (in_class=1, brace_depth=10):         
📄 Line 644 (in_class=1, brace_depth=10):         // 🔥 【LOGGER仕込み】この関数が呼ばれたことを記録！
📄 Line 645 (in_class=1, brace_depth=10):         if (g_debug_mode) {
📄 Line 646 (in_class=1, brace_depth=11):             std::cerr << "🔥 【LOGGER仕込み】gemini_line_level_double_attack()が呼ばれた！行:" << line_number 
📄 Line 647 (in_class=1, brace_depth=11):                       << ", 内容: " << line.substr(0, 30) << "..." << std::endl;
📄 Line 648 (in_class=1, brace_depth=11):         }
📄 Line 649 (in_class=1, brace_depth=10):         
📄 Line 650 (in_class=1, brace_depth=10):         // 🎯 アタックパターン1: オブジェクトメソッド (method() {})
📄 Line 651 (in_class=1, brace_depth=10):         if (g_debug_mode) std::cerr << "🔥 【LOGGER仕込み】gemini_attack_object_methods()実行中..." << std::endl;
📄 Line 652 (in_class=1, brace_depth=10):         gemini_attack_object_methods(line, line_number, result, existing_functions);
📄 Line 653 (in_class=1, brace_depth=10):         
📄 Line 654 (in_class=1, brace_depth=10):         // 🎯 アタックパターン2: プロパティ構文 (prop: function() {})
📄 Line 655 (in_class=1, brace_depth=10):         if (g_debug_mode) std::cerr << "🔥 【LOGGER仕込み】gemini_attack_property_functions()実行中..." << std::endl;
📄 Line 656 (in_class=1, brace_depth=10):         gemini_attack_property_functions(line, line_number, result, existing_functions);
📄 Line 657 (in_class=1, brace_depth=10):         
📄 Line 658 (in_class=1, brace_depth=10):         // 🎯 アタックパターン3: アロー関数プロパティ (prop: () => {})
📄 Line 659 (in_class=1, brace_depth=10):         if (g_debug_mode) std::cerr << "🔥 【LOGGER仕込み】gemini_attack_arrow_properties()実行中..." << std::endl;
📄 Line 660 (in_class=1, brace_depth=10):         gemini_attack_arrow_properties(line, line_number, result, existing_functions);
📄 Line 661 (in_class=1, brace_depth=10):         
📄 Line 662 (in_class=1, brace_depth=10):         // 🎯 アタックパターン4: インターフェースメソッド (method(): type;)
📄 Line 663 (in_class=1, brace_depth=10):         if (g_debug_mode) std::cerr << "🔥 【LOGGER仕込み】gemini_attack_interface_methods()実行中..." << std::endl;
📄 Line 664 (in_class=1, brace_depth=10):         gemini_attack_interface_methods(line, line_number, result, existing_functions);
📄 Line 665 (in_class=1, brace_depth=10):     }
📄 Line 666 (in_class=1, brace_depth=9):     
📄 Line 667 (in_class=1, brace_depth=9):     // 🎯 オブジェクトメソッド攻撃 (method() {})
📄 Line 668 (in_class=1, brace_depth=9):     void gemini_attack_object_methods(const std::string& line, size_t line_number,
📄 Line 669 (in_class=1, brace_depth=9):                                      AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 670 (in_class=1, brace_depth=10):         // にゃー先生推奨パターン: ^\s*([a-zA-Z0-9_$]+)\s*\([^)]*\)\s*{
📄 Line 671 (in_class=1, brace_depth=11):         std::regex object_method_pattern(R"(^\s*([a-zA-Z0-9_$]+)\s*\([^)]*\)\s*\{)");
📄 Line 672 (in_class=1, brace_depth=12):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 672
    📝 Line content: '        std::smatch match;'
📄 Line 673 (in_class=1, brace_depth=12):         
📄 Line 674 (in_class=1, brace_depth=12):         if (std::regex_search(line, match, object_method_pattern)) {
📄 Line 675 (in_class=1, brace_depth=13):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class TypeScriptPEGTLAnalyzer at line 675
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 676 (in_class=1, brace_depth=13):             
📄 Line 677 (in_class=1, brace_depth=13):             // 制御フロー文除外
📄 Line 678 (in_class=1, brace_depth=13):             if (method_name == "if" || method_name == "for" || method_name == "while" || 
📄 Line 679 (in_class=1, brace_depth=13):                 method_name == "switch" || method_name == "try" || method_name == "catch" ||
📄 Line 680 (in_class=1, brace_depth=13):                 method_name == "else" || method_name == "return") {
📄 Line 681 (in_class=1, brace_depth=14):                 return;
📄 Line 682 (in_class=1, brace_depth=14):             }
📄 Line 683 (in_class=1, brace_depth=13):             
📄 Line 684 (in_class=1, brace_depth=13):             if (existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 685 (in_class=1, brace_depth=14):                 if (g_debug_mode) {
📄 Line 686 (in_class=1, brace_depth=15):                     std::cerr << "🎯 【LOGGER仕込み】Geminiオブジェクトメソッド発見: " << method_name 
📄 Line 687 (in_class=1, brace_depth=15):                               << " ← 呼び出し元: gemini_attack_object_methods()" << std::endl;
📄 Line 688 (in_class=1, brace_depth=15):                 }
📄 Line 689 (in_class=1, brace_depth=14):                 
📄 Line 690 (in_class=1, brace_depth=14):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 690
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 691 (in_class=1, brace_depth=14):                 func_info.name = method_name;
📄 Line 692 (in_class=1, brace_depth=14):                 func_info.start_line = line_number;
📄 Line 693 (in_class=1, brace_depth=14):                 
📄 Line 694 (in_class=1, brace_depth=14):                 // 詳細検出
📄 Line 695 (in_class=1, brace_depth=14):                 if (line.find("async") != std::string::npos) {
📄 Line 696 (in_class=1, brace_depth=15):                     func_info.is_async = true;
📄 Line 697 (in_class=1, brace_depth=15):                 }
📄 Line 698 (in_class=1, brace_depth=14):                 
📄 Line 699 (in_class=1, brace_depth=14):                 result.functions.push_back(func_info);
📄 Line 700 (in_class=1, brace_depth=14):                 existing_functions.insert(method_name);
📄 Line 701 (in_class=1, brace_depth=14):             }
📄 Line 702 (in_class=1, brace_depth=13):         }
📄 Line 703 (in_class=1, brace_depth=12):     }
📄 Line 704 (in_class=1, brace_depth=11):     
📄 Line 705 (in_class=1, brace_depth=11):     // 🎯 プロパティ構文攻撃 (prop: function() {})
📄 Line 706 (in_class=1, brace_depth=11):     void gemini_attack_property_functions(const std::string& line, size_t line_number,
📄 Line 707 (in_class=1, brace_depth=11):                                          AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 708 (in_class=1, brace_depth=12):         // Gemini先生推奨パターン: ^\s*([a-zA-Z0-9_$]+)\s*:\s*(?:async\s+)?function
📄 Line 709 (in_class=1, brace_depth=12):         std::regex property_function_pattern(R"(^\s*([a-zA-Z0-9_$]+)\s*:\s*(?:async\s+)?function)");
📄 Line 710 (in_class=1, brace_depth=12):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 710
    📝 Line content: '        std::smatch match;'
📄 Line 711 (in_class=1, brace_depth=12):         
📄 Line 712 (in_class=1, brace_depth=12):         if (std::regex_search(line, match, property_function_pattern)) {
📄 Line 713 (in_class=1, brace_depth=13):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class TypeScriptPEGTLAnalyzer at line 713
    📝 Line content: '            std::string prop_name = match[1].str();'
📄 Line 714 (in_class=1, brace_depth=13):             
📄 Line 715 (in_class=1, brace_depth=13):             if (existing_functions.find(prop_name) == existing_functions.end()) {
📄 Line 716 (in_class=1, brace_depth=14):                 if (g_debug_mode) {
📄 Line 717 (in_class=1, brace_depth=15):                     std::cerr << "🎯 【LOGGER仕込み】Geminiプロパティ関数発見: " << prop_name 
📄 Line 718 (in_class=1, brace_depth=15):                               << " ← 呼び出し元: gemini_attack_property_functions()" << std::endl;
📄 Line 719 (in_class=1, brace_depth=15):                 }
📄 Line 720 (in_class=1, brace_depth=14):                 
📄 Line 721 (in_class=1, brace_depth=14):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 721
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 722 (in_class=1, brace_depth=14):                 func_info.name = prop_name;
📄 Line 723 (in_class=1, brace_depth=14):                 func_info.start_line = line_number;
📄 Line 724 (in_class=1, brace_depth=14):                 
📄 Line 725 (in_class=1, brace_depth=14):                 if (line.find("async") != std::string::npos) {
📄 Line 726 (in_class=1, brace_depth=15):                     func_info.is_async = true;
📄 Line 727 (in_class=1, brace_depth=15):                 }
📄 Line 728 (in_class=1, brace_depth=14):                 
📄 Line 729 (in_class=1, brace_depth=14):                 result.functions.push_back(func_info);
📄 Line 730 (in_class=1, brace_depth=14):                 existing_functions.insert(prop_name);
📄 Line 731 (in_class=1, brace_depth=14):             }
📄 Line 732 (in_class=1, brace_depth=13):         }
📄 Line 733 (in_class=1, brace_depth=12):     }
📄 Line 734 (in_class=1, brace_depth=11):     
📄 Line 735 (in_class=1, brace_depth=11):     // 🎯 アロー関数プロパティ攻撃 (prop: () => {})
📄 Line 736 (in_class=1, brace_depth=11):     void gemini_attack_arrow_properties(const std::string& line, size_t line_number,
📄 Line 737 (in_class=1, brace_depth=11):                                        AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 738 (in_class=1, brace_depth=12):         // Gemini先生推奨パターン: ^\s*([a-zA-Z0-9_$]+)\s*:\s*\(.*\)\s*=>
📄 Line 739 (in_class=1, brace_depth=12):         std::regex arrow_property_pattern(R"(^\s*([a-zA-Z0-9_$]+)\s*:\s*\(.*\)\s*=>)");
📄 Line 740 (in_class=1, brace_depth=12):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 740
    📝 Line content: '        std::smatch match;'
📄 Line 741 (in_class=1, brace_depth=12):         
📄 Line 742 (in_class=1, brace_depth=12):         if (std::regex_search(line, match, arrow_property_pattern)) {
📄 Line 743 (in_class=1, brace_depth=13):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class TypeScriptPEGTLAnalyzer at line 743
    📝 Line content: '            std::string prop_name = match[1].str();'
📄 Line 744 (in_class=1, brace_depth=13):             
📄 Line 745 (in_class=1, brace_depth=13):             if (existing_functions.find(prop_name) == existing_functions.end()) {
📄 Line 746 (in_class=1, brace_depth=14):                 if (g_debug_mode) {
📄 Line 747 (in_class=1, brace_depth=15):                     std::cerr << "🎯 【LOGGER仕込み】Geminiアロー関数プロパティ発見: " << prop_name 
📄 Line 748 (in_class=1, brace_depth=15):                               << " ← 呼び出し元: gemini_attack_arrow_properties()" << std::endl;
📄 Line 749 (in_class=1, brace_depth=15):                 }
📄 Line 750 (in_class=1, brace_depth=14):                 
📄 Line 751 (in_class=1, brace_depth=14):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 751
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 752 (in_class=1, brace_depth=14):                 func_info.name = prop_name;
📄 Line 753 (in_class=1, brace_depth=14):                 func_info.start_line = line_number;
📄 Line 754 (in_class=1, brace_depth=14):                 func_info.is_arrow_function = true;
📄 Line 755 (in_class=1, brace_depth=14):                 
📄 Line 756 (in_class=1, brace_depth=14):                 result.functions.push_back(func_info);
📄 Line 757 (in_class=1, brace_depth=14):                 existing_functions.insert(prop_name);
📄 Line 758 (in_class=1, brace_depth=14):             }
📄 Line 759 (in_class=1, brace_depth=13):         }
📄 Line 760 (in_class=1, brace_depth=12):     }
📄 Line 761 (in_class=1, brace_depth=11):     
📄 Line 762 (in_class=1, brace_depth=11):     // 🎯 インターフェースメソッド攻撃 (method(): type;)
📄 Line 763 (in_class=1, brace_depth=11):     void gemini_attack_interface_methods(const std::string& line, size_t line_number,
📄 Line 764 (in_class=1, brace_depth=11):                                         AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 765 (in_class=1, brace_depth=12):         // Gemini先生推奨パターン: ^\s*([a-zA-Z0-9_$]+)\s*\(([^;]*)\)\s*:\s*[^;]+;
📄 Line 766 (in_class=1, brace_depth=12):         std::regex interface_method_pattern(R"(^\s*([a-zA-Z0-9_$]+)\s*\([^)]*\)\s*:\s*[^;]+;)");
📄 Line 767 (in_class=1, brace_depth=12):         std::smatch match;
🎯 Found member variable: match in class TypeScriptPEGTLAnalyzer at line 767
    📝 Line content: '        std::smatch match;'
📄 Line 768 (in_class=1, brace_depth=12):         
📄 Line 769 (in_class=1, brace_depth=12):         if (std::regex_search(line, match, interface_method_pattern)) {
📄 Line 770 (in_class=1, brace_depth=13):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class TypeScriptPEGTLAnalyzer at line 770
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 771 (in_class=1, brace_depth=13):             
📄 Line 772 (in_class=1, brace_depth=13):             if (existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 773 (in_class=1, brace_depth=14):                 if (g_debug_mode) {
📄 Line 774 (in_class=1, brace_depth=15):                     std::cerr << "🎯 【LOGGER仕込み】Geminiインターフェースメソッド発見: " << method_name 
📄 Line 775 (in_class=1, brace_depth=15):                               << " ← 呼び出し元: gemini_attack_interface_methods()" << std::endl;
📄 Line 776 (in_class=1, brace_depth=15):                 }
📄 Line 777 (in_class=1, brace_depth=14):                 
📄 Line 778 (in_class=1, brace_depth=14):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class TypeScriptPEGTLAnalyzer at line 778
    📝 Line content: '                FunctionInfo func_info;'
📍 Reached end_line 778 for class TypeScriptPEGTLAnalyzer
🔍 Processing class: 'struct:FunctionRange'
📦 Struct detected, clean name: 'FunctionRange'
🎯 Found correct struct 'FunctionRange' at line 789
✅ Corrected start_line for 'struct:FunctionRange': 789
🔍 Scanning lines 789-1528 for class 'FunctionRange'
🎯 Class start detected at line 789:     struct FunctionRange {
📄 Line 790 (in_class=1, brace_depth=1):         size_t start_line;
🎯 Found member variable: start_line in class FunctionRange at line 790
    📝 Line content: '        size_t start_line;'
📄 Line 791 (in_class=1, brace_depth=1):         size_t end_line;
🎯 Found member variable: end_line in class FunctionRange at line 791
    📝 Line content: '        size_t end_line;'
📄 Line 792 (in_class=1, brace_depth=1):         size_t indent_level;  // インデントレベルで深さを管理
🎯 Found member variable: indent_level in class FunctionRange at line 792
    📝 Line content: '        size_t indent_level;  // インデントレベルで深さを管理'
📄 Line 793 (in_class=1, brace_depth=1):     };
🔍 Before update_statistics: classes=4, functions=52
🔍 After update_statistics: stats.class_count=4, stats.function_count=52
[23:18:33.202] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/typescript/typescript_pegtl_analyzer.hpp
🔥 Final return: result.stats.class_count=4, result.stats.function_count=52
[23:18:33.202] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/python/python_analyzer.cpp (17051 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=218, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=0, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:33.202] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 429行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 429行処理 (333ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 3
🔍 Debug: Classes before=1, after=2, Functions before=0, after=3
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-10 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🐍 Python Language Analyzer - Python専用解析エンジン (std::regex完全除去版)
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=3
🔍 After update_statistics: stats.class_count=2, stats.function_count=3
[23:18:33.537] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/python/python_analyzer.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=3
[23:18:33.538] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/go/go_analyzer.cpp (18816 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=268, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=0, has_struct=0, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:33.538] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 537行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 537行処理 (413ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 1
🔍 Debug: Classes before=1, after=2, Functions before=0, after=1
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-11 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🐹 Go Language Analyzer Implementation
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=1
🔍 After update_statistics: stats.class_count=2, stats.function_count=1
[23:18:33.953] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/go/go_analyzer.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=1
[23:18:33.953] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/csharp/csharp_pegtl_analyzer.cpp (528 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=2, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=0, has_struct=0, has_namespace=1
📊 Trigger reason: C++ patterns found but no classes detected
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:33.953] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 13行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 13行処理 (10ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 0
🔍 Debug: Classes before=1, after=2, Functions before=0, after=0
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-8 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🌟 C# PEGTL Analyzer Implementation - 革新的構文解析エンジン
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=0
🔍 After update_statistics: stats.class_count=2, stats.function_count=0
[23:18:33.964] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/csharp/csharp_pegtl_analyzer.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=0
[23:18:33.964] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/cpp/cpp_analyzer.cpp (32909 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=402, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=1, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:33.964] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 865行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 865行処理 (668ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 6, Functions: 26
🔍 Debug: Classes before=1, after=6, Functions before=0, after=26
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-10 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🔥 C++ Code Analyzer Implementation - 地獄のnyamesh_v22対応版
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Processing class: 'TemplateParser'
🎯 Found correct class 'TemplateParser' at line 553
✅ Corrected start_line for 'TemplateParser': 553
🔍 Scanning lines 553-555 for class 'TemplateParser'
🎯 Class start detected at line 553: class TemplateParser {
📄 Line 554 (in_class=1, brace_depth=1): private:
📄 Line 555 (in_class=1, brace_depth=1):     const std::string& content_;
🎯 Found member variable: content_ in class TemplateParser at line 555
    📝 Line content: '    const std::string& content_;'
📍 Reached end_line 555 for class TemplateParser
🔍 Processing class: 'struct:TemplateRange'
📦 Struct detected, clean name: 'TemplateRange'
🎯 Found correct struct 'TemplateRange' at line 561
✅ Corrected start_line for 'struct:TemplateRange': 561
🔍 Scanning lines 561-688 for class 'TemplateRange'
🎯 Class start detected at line 561:     struct TemplateRange {
📄 Line 562 (in_class=1, brace_depth=1):         size_t start_pos;
🎯 Found member variable: start_pos in class TemplateRange at line 562
    📝 Line content: '        size_t start_pos;'
📄 Line 563 (in_class=1, brace_depth=1):         size_t end_pos;
🎯 Found member variable: end_pos in class TemplateRange at line 563
    📝 Line content: '        size_t end_pos;'
📄 Line 564 (in_class=1, brace_depth=1):         std::string parameters;
🎯 Found member variable: parameters in class TemplateRange at line 564
    📝 Line content: '        std::string parameters;'
📄 Line 565 (in_class=1, brace_depth=1):         bool valid = false;
🎯 Found member variable: valid in class TemplateRange at line 565
    📝 Line content: '        bool valid = false;'
📄 Line 566 (in_class=1, brace_depth=1):     };
🔍 Processing class: 'MacroParser'
🎯 Found correct class 'MacroParser' at line 694
✅ Corrected start_line for 'MacroParser': 694
🔍 Scanning lines 694-696 for class 'MacroParser'
🎯 Class start detected at line 694: class MacroParser {
📄 Line 695 (in_class=1, brace_depth=1): private:
📄 Line 696 (in_class=1, brace_depth=1):     const std::string& content_;
🎯 Found member variable: content_ in class MacroParser at line 696
    📝 Line content: '    const std::string& content_;'
📍 Reached end_line 696 for class MacroParser
🔍 Processing class: 'struct:MacroInfo'
📦 Struct detected, clean name: 'MacroInfo'
🎯 Found correct struct 'MacroInfo' at line 702
✅ Corrected start_line for 'struct:MacroInfo': 702
🔍 Scanning lines 702-870 for class 'MacroInfo'
🎯 Class start detected at line 702:     struct MacroInfo {
📄 Line 703 (in_class=1, brace_depth=1):         std::string name;
🎯 Found member variable: name in class MacroInfo at line 703
    📝 Line content: '        std::string name;'
📄 Line 704 (in_class=1, brace_depth=1):         std::string definition;
🎯 Found member variable: definition in class MacroInfo at line 704
    📝 Line content: '        std::string definition;'
📄 Line 705 (in_class=1, brace_depth=1):         size_t line_number = 0;
🎯 Found member variable: line_number in class MacroInfo at line 705
    📝 Line content: '        size_t line_number = 0;'
📄 Line 706 (in_class=1, brace_depth=1):         bool valid = false;
🎯 Found member variable: valid in class MacroInfo at line 706
    📝 Line content: '        bool valid = false;'
📄 Line 707 (in_class=1, brace_depth=1):     };
🔍 Before update_statistics: classes=6, functions=26
🔍 After update_statistics: stats.class_count=6, stats.function_count=26
[23:18:34.642] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/cpp/cpp_analyzer.cpp
🔥 Final return: result.stats.class_count=6, result.stats.function_count=26
[23:18:34.642] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/cpp/cpp_language_analyzer.cpp (28343 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=345, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=1, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:34.643] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 727行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 727行処理 (569ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 2
🔍 Debug: Classes before=1, after=2, Functions before=0, after=2
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-7 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🔥 C++ Language Analyzer - C++専用解析エンジン
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=2
🔍 After update_statistics: stats.class_count=2, stats.function_count=2
[23:18:35.214] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/cpp/cpp_language_analyzer.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=2
[23:18:35.214] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/rust/rust_analyzer.cpp (32585 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=341, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=0, has_struct=1, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:35.214] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 825行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 825行処理 (640ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 18
🔍 Debug: Classes before=1, after=2, Functions before=0, after=18
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-5 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🦀 Rust Language Analyzer Implementation
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=18
🔍 After update_statistics: stats.class_count=2, stats.function_count=18
[23:18:35.856] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/rust/rust_analyzer.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=18
[23:18:35.856] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/javascript/javascript_minimal_grammar.hpp (9161 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=2, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=1, has_namespace=1
📊 Trigger reason: C++ patterns found but no classes detected
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:35.857] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 301行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 301行処理 (231ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 43, Functions: 0
🔍 Debug: Classes before=1, after=43, Functions before=0, after=0
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-8 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: #pragma once
📄 Line 2 (in_class=1, brace_depth=0): 
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Processing class: 'namespace:javascript'
⏭️  Skipping namespace: namespace:javascript
🔍 Processing class: 'namespace:minimal_grammar'
⏭️  Skipping namespace: namespace:minimal_grammar
🔍 Processing class: 'struct:identifier'
📦 Struct detected, clean name: 'identifier'
🎯 Found correct struct 'identifier' at line 22
✅ Corrected start_line for 'struct:identifier': 22
🔍 Scanning lines 22-22 for class 'identifier'
🎯 Class start detected at line 22: struct identifier : seq<sor<alpha, one<'_', '$'>>, star<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:ws'
📦 Struct detected, clean name: 'ws'
🎯 Found correct struct 'ws' at line 25
✅ Corrected start_line for 'struct:ws': 25
🔍 Scanning lines 25-25 for class 'ws'
🎯 Class start detected at line 25: struct ws : star<space> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:newline'
📦 Struct detected, clean name: 'newline'
🎯 Found correct struct 'newline' at line 26
✅ Corrected start_line for 'struct:newline': 26
🔍 Scanning lines 26-26 for class 'newline'
🎯 Class start detected at line 26: struct newline : sor<one<'\n'>, one<'\r'>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:single_comment'
📦 Struct detected, clean name: 'single_comment'
🎯 Found correct struct 'single_comment' at line 27
✅ Corrected start_line for 'struct:single_comment': 27
🔍 Scanning lines 27-27 for class 'single_comment'
🎯 Class start detected at line 27: struct single_comment : seq<TAO_PEGTL_STRING("//"), star<not_one<'\n', '\r'>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:multi_comment'
📦 Struct detected, clean name: 'multi_comment'
🎯 Found correct struct 'multi_comment' at line 28
✅ Corrected start_line for 'struct:multi_comment': 28
🔍 Scanning lines 28-34 for class 'multi_comment'
🎯 Class start detected at line 28: struct multi_comment : seq<TAO_PEGTL_STRING("/*"), until<TAO_PEGTL_STRING("*/")>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:comment'
📦 Struct detected, clean name: 'comment'
🎯 Found correct struct 'comment' at line 29
✅ Corrected start_line for 'struct:comment': 29
🔍 Scanning lines 29-34 for class 'comment'
🎯 Class start detected at line 29: struct comment : sor<single_comment, multi_comment> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:ignore'
📦 Struct detected, clean name: 'ignore'
🎯 Found correct struct 'ignore' at line 30
✅ Corrected start_line for 'struct:ignore': 30
🔍 Scanning lines 30-34 for class 'ignore'
🎯 Class start detected at line 30: struct ignore : star<sor<space, comment, newline>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:function_keyword'
📦 Struct detected, clean name: 'function_keyword'
🎯 Found correct struct 'function_keyword' at line 37
✅ Corrected start_line for 'struct:function_keyword': 37
🔍 Scanning lines 37-37 for class 'function_keyword'
🎯 Class start detected at line 37: struct function_keyword : seq<TAO_PEGTL_STRING("function"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:async_keyword'
📦 Struct detected, clean name: 'async_keyword'
🎯 Found correct struct 'async_keyword' at line 38
✅ Corrected start_line for 'struct:async_keyword': 38
🔍 Scanning lines 38-38 for class 'async_keyword'
🎯 Class start detected at line 38: struct async_keyword : seq<TAO_PEGTL_STRING("async"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:const_keyword'
📦 Struct detected, clean name: 'const_keyword'
🎯 Found correct struct 'const_keyword' at line 39
✅ Corrected start_line for 'struct:const_keyword': 39
🔍 Scanning lines 39-39 for class 'const_keyword'
🎯 Class start detected at line 39: struct const_keyword : seq<TAO_PEGTL_STRING("const"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:let_keyword'
📦 Struct detected, clean name: 'let_keyword'
🎯 Found correct struct 'let_keyword' at line 40
✅ Corrected start_line for 'struct:let_keyword': 40
🔍 Scanning lines 40-40 for class 'let_keyword'
🎯 Class start detected at line 40: struct let_keyword : seq<TAO_PEGTL_STRING("let"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:var_keyword'
📦 Struct detected, clean name: 'var_keyword'
🎯 Found correct struct 'var_keyword' at line 41
✅ Corrected start_line for 'struct:var_keyword': 41
🔍 Scanning lines 41-43 for class 'var_keyword'
🎯 Class start detected at line 41: struct var_keyword : seq<TAO_PEGTL_STRING("var"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:class_keyword'
📦 Struct detected, clean name: 'class_keyword'
🎯 Found correct struct 'class_keyword' at line 42
✅ Corrected start_line for 'struct:class_keyword': 42
🔍 Scanning lines 42-43 for class 'class_keyword'
🎯 Class start detected at line 42: struct class_keyword : seq<TAO_PEGTL_STRING("class"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:export_keyword'
📦 Struct detected, clean name: 'export_keyword'
🎯 Found correct struct 'export_keyword' at line 43
✅ Corrected start_line for 'struct:export_keyword': 43
🔍 Scanning lines 43-43 for class 'export_keyword'
🎯 Class start detected at line 43: struct export_keyword : seq<TAO_PEGTL_STRING("export"), not_at<sor<alnum, one<'_', '$'>>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:block'
📦 Struct detected, clean name: 'block'
🎯 Found correct struct 'block' at line 46
✅ Corrected start_line for 'struct:block': 46
🔍 Scanning lines 46-47 for class 'block'
🎯 Class start detected at line 46: struct block;
📄 Line 47 (in_class=1, brace_depth=0): struct block : seq<one<'{'>, star<sor<block, not_one<'}'>>>, one<'}'>> {};
🔍 Processing class: 'struct:function_params'
📦 Struct detected, clean name: 'function_params'
🎯 Found correct struct 'function_params' at line 50
✅ Corrected start_line for 'struct:function_params': 50
🔍 Scanning lines 50-50 for class 'function_params'
🎯 Class start detected at line 50: struct function_params : seq<one<'('>, until<one<')'>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:type_annotation'
📦 Struct detected, clean name: 'type_annotation'
🎯 Found correct struct 'type_annotation' at line 53
✅ Corrected start_line for 'struct:type_annotation': 53
🔍 Scanning lines 53-53 for class 'type_annotation'
🎯 Class start detected at line 53: struct type_annotation : seq<one<':'>, star<not_one<'{', ';'>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: '', ';'>>> {'
🔍 Processing segments from body: '', ';'>>> {'
📋 Segment[0-4]: '', ''
📋 Segment[5-11]: ''>>> {'
🔍 Processing class: 'struct:generics'
📦 Struct detected, clean name: 'generics'
🎯 Found correct struct 'generics' at line 56
✅ Corrected start_line for 'struct:generics': 56
🔍 Scanning lines 56-56 for class 'generics'
🎯 Class start detected at line 56: struct generics : seq<one<'<'>, until<one<'>'>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:function_decl'
📦 Struct detected, clean name: 'function_decl'
🎯 Found correct struct 'function_decl' at line 59
✅ Corrected start_line for 'struct:function_decl': 59
🔍 Scanning lines 59-67 for class 'function_decl'
🎯 Class start detected at line 59: struct function_decl : seq<
📄 Line 60 (in_class=1, brace_depth=0):     function_keyword,
🔍 Processing class: 'struct:arrow_function'
📦 Struct detected, clean name: 'arrow_function'
🎯 Found correct struct 'arrow_function' at line 70
✅ Corrected start_line for 'struct:arrow_function': 70
🔍 Scanning lines 70-85 for class 'arrow_function'
🎯 Class start detected at line 70: struct arrow_function : seq<
📄 Line 71 (in_class=1, brace_depth=0):     sor<const_keyword, let_keyword, var_keyword>,
🔍 Processing class: 'struct:extends_keyword'
📦 Struct detected, clean name: 'extends_keyword'
🎯 Found correct struct 'extends_keyword' at line 88
✅ Corrected start_line for 'struct:extends_keyword': 88
🔍 Scanning lines 88-88 for class 'extends_keyword'
🎯 Class start detected at line 88: struct extends_keyword : TAO_PEGTL_STRING("extends") {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:class_header'
📦 Struct detected, clean name: 'class_header'
🎯 Found correct struct 'class_header' at line 91
✅ Corrected start_line for 'struct:class_header': 91
🔍 Scanning lines 91-101 for class 'class_header'
🎯 Class start detected at line 91: struct class_header : seq<
📄 Line 92 (in_class=1, brace_depth=0):     class_keyword,
🔍 Processing class: 'struct:class_method'
📦 Struct detected, clean name: 'class_method'
🎯 Found correct struct 'class_method' at line 104
✅ Corrected start_line for 'struct:class_method': 104
🔍 Scanning lines 104-115 for class 'class_method'
🎯 Class start detected at line 104: struct class_method : seq<
📄 Line 105 (in_class=1, brace_depth=0):     star<space>,  // インデント許可
🔍 Processing class: 'struct:class_content'
📦 Struct detected, clean name: 'class_content'
🎯 Found correct struct 'class_content' at line 118
✅ Corrected start_line for 'struct:class_content': 118
🔍 Scanning lines 118-118 for class 'class_content'
🎯 Class start detected at line 118: struct class_content : star<sor<class_method, not_one<'}'>>> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:class_block'
📦 Struct detected, clean name: 'class_block'
🎯 Found correct struct 'class_block' at line 121
✅ Corrected start_line for 'struct:class_block': 121
🔍 Scanning lines 121-130 for class 'class_block'
🎯 Class start detected at line 121: struct class_block : seq<
📄 Line 122 (in_class=1, brace_depth=0):     class_header,
🔍 Processing class: 'struct:import_keyword'
📦 Struct detected, clean name: 'import_keyword'
🎯 Found correct struct 'import_keyword' at line 133
✅ Corrected start_line for 'struct:import_keyword': 133
🔍 Scanning lines 133-134 for class 'import_keyword'
🎯 Class start detected at line 133: struct import_keyword : TAO_PEGTL_STRING("import") {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:from_keyword'
📦 Struct detected, clean name: 'from_keyword'
🎯 Found correct struct 'from_keyword' at line 134
✅ Corrected start_line for 'struct:from_keyword': 134
🔍 Scanning lines 134-134 for class 'from_keyword'
🎯 Class start detected at line 134: struct from_keyword : TAO_PEGTL_STRING("from") {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'struct:string_literal'
📦 Struct detected, clean name: 'string_literal'
🎯 Found correct struct 'string_literal' at line 137
✅ Corrected start_line for 'struct:string_literal': 137
🔍 Scanning lines 137-140 for class 'string_literal'
🎯 Class start detected at line 137: struct string_literal : sor<
📄 Line 138 (in_class=1, brace_depth=0):     seq<one<'"'>, until<one<'"'>>>,
🔍 Processing class: 'struct:import_stmt'
📦 Struct detected, clean name: 'import_stmt'
🎯 Found correct struct 'import_stmt' at line 143
✅ Corrected start_line for 'struct:import_stmt': 143
🔍 Scanning lines 143-155 for class 'import_stmt'
🎯 Class start detected at line 143: struct import_stmt : seq<
📄 Line 144 (in_class=1, brace_depth=0):     import_keyword,
🔍 Processing class: 'struct:simple_function'
📦 Struct detected, clean name: 'simple_function'
🎯 Found correct struct 'simple_function' at line 158
✅ Corrected start_line for 'struct:simple_function': 158
🔍 Scanning lines 158-171 for class 'simple_function'
🎯 Class start detected at line 158: struct simple_function : seq<
📄 Line 159 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:async_function'
📦 Struct detected, clean name: 'async_function'
🎯 Found correct struct 'async_function' at line 174
✅ Corrected start_line for 'struct:async_function': 174
🔍 Scanning lines 174-185 for class 'async_function'
🎯 Class start detected at line 174: struct async_function : seq<
📄 Line 175 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:export_function'
📦 Struct detected, clean name: 'export_function'
🎯 Found correct struct 'export_function' at line 188
✅ Corrected start_line for 'struct:export_function': 188
🔍 Scanning lines 188-203 for class 'export_function'
🎯 Class start detected at line 188: struct export_function : seq<
📄 Line 189 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:simple_arrow'
📦 Struct detected, clean name: 'simple_arrow'
🎯 Found correct struct 'simple_arrow' at line 206
✅ Corrected start_line for 'struct:simple_arrow': 206
🔍 Scanning lines 206-219 for class 'simple_arrow'
🎯 Class start detected at line 206: struct simple_arrow : seq<
📄 Line 207 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:async_arrow'
📦 Struct detected, clean name: 'async_arrow'
🎯 Found correct struct 'async_arrow' at line 222
✅ Corrected start_line for 'struct:async_arrow': 222
🔍 Scanning lines 222-237 for class 'async_arrow'
🎯 Class start detected at line 222: struct async_arrow : seq<
📄 Line 223 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:simple_import'
📦 Struct detected, clean name: 'simple_import'
🎯 Found correct struct 'simple_import' at line 240
✅ Corrected start_line for 'struct:simple_import': 240
🔍 Scanning lines 240-252 for class 'simple_import'
🎯 Class start detected at line 240: struct simple_import : seq<
📄 Line 241 (in_class=1, brace_depth=0):     import_keyword,
🔍 Processing class: 'struct:simple_class'
📦 Struct detected, clean name: 'simple_class'
🎯 Found correct struct 'simple_class' at line 255
✅ Corrected start_line for 'struct:simple_class': 255
🔍 Scanning lines 255-262 for class 'simple_class'
🎯 Class start detected at line 255: struct simple_class : seq<
📄 Line 256 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:export_class'
📦 Struct detected, clean name: 'export_class'
🎯 Found correct struct 'export_class' at line 265
✅ Corrected start_line for 'struct:export_class': 265
🔍 Scanning lines 265-280 for class 'export_class'
🎯 Class start detected at line 265: struct export_class : seq<
📄 Line 266 (in_class=1, brace_depth=0):     star<space>,  // インデントを許可
🔍 Processing class: 'struct:javascript_element'
📦 Struct detected, clean name: 'javascript_element'
🎯 Found correct struct 'javascript_element' at line 283
✅ Corrected start_line for 'struct:javascript_element': 283
🔍 Scanning lines 283-292 for class 'javascript_element'
🎯 Class start detected at line 283: struct javascript_element : sor<
📄 Line 284 (in_class=1, brace_depth=0):     export_class,
🔍 Processing class: 'struct:javascript_minimal'
📦 Struct detected, clean name: 'javascript_minimal'
🎯 Found correct struct 'javascript_minimal' at line 295
✅ Corrected start_line for 'struct:javascript_minimal': 295
🔍 Scanning lines 295-303 for class 'javascript_minimal'
🎯 Class start detected at line 295: struct javascript_minimal : seq<
📄 Line 296 (in_class=1, brace_depth=0):     ignore,
🔍 Before update_statistics: classes=43, functions=0
🔍 After update_statistics: stats.class_count=43, stats.function_count=0
[23:18:36.097] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/javascript/javascript_minimal_grammar.hpp
🔥 Final return: result.stats.class_count=43, result.stats.function_count=0
[23:18:36.098] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/javascript/javascript_pegtl_analyzer.hpp (70513 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=777, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=1, has_struct=1, has_namespace=1
📊 Trigger reason: High complexity with low detection
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:36.098] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 1458行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 1458行処理 (1142ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 6, Functions: 36
🔍 Debug: Classes before=1, after=6, Functions before=0, after=36
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-9 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: #pragma once
📄 Line 2 (in_class=1, brace_depth=0): 
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Processing class: 'struct:JavaScriptParseState'
📦 Struct detected, clean name: 'JavaScriptParseState'
🎯 Found correct struct 'JavaScriptParseState' at line 31
✅ Corrected start_line for 'struct:JavaScriptParseState': 31
🔍 Scanning lines 31-40 for class 'JavaScriptParseState'
🎯 Class start detected at line 31: struct JavaScriptParseState {
📄 Line 32 (in_class=1, brace_depth=1):     std::vector<ClassInfo> classes;
🎯 Found member variable: classes in class JavaScriptParseState at line 32
    📝 Line content: '    std::vector<ClassInfo> classes;'
📄 Line 33 (in_class=1, brace_depth=1):     std::vector<FunctionInfo> functions;
🎯 Found member variable: functions in class JavaScriptParseState at line 33
    📝 Line content: '    std::vector<FunctionInfo> functions;'
📄 Line 34 (in_class=1, brace_depth=1):     std::vector<ImportInfo> imports;
🎯 Found member variable: imports in class JavaScriptParseState at line 34
    📝 Line content: '    std::vector<ImportInfo> imports;'
📄 Line 35 (in_class=1, brace_depth=1):     std::vector<ExportInfo> exports;
🎯 Found member variable: exports in class JavaScriptParseState at line 35
    📝 Line content: '    std::vector<ExportInfo> exports;'
📄 Line 36 (in_class=1, brace_depth=1):     
📄 Line 37 (in_class=1, brace_depth=1):     // 現在の解析位置情報
📄 Line 38 (in_class=1, brace_depth=1):     size_t current_line = 1;
🎯 Found member variable: current_line in class JavaScriptParseState at line 38
    📝 Line content: '    size_t current_line = 1;'
📄 Line 39 (in_class=1, brace_depth=1):     std::string current_content;
🎯 Found member variable: current_content in class JavaScriptParseState at line 39
    📝 Line content: '    std::string current_content;'
📄 Line 40 (in_class=1, brace_depth=1):     
📍 Reached end_line 40 for class JavaScriptParseState
🔍 Processing class: 'struct:javascript_action'
📦 Struct detected, clean name: 'javascript_action'
🎯 Found correct struct 'javascript_action' at line 56
✅ Corrected start_line for 'struct:javascript_action': 56
🔍 Scanning lines 56-531 for class 'javascript_action'
🎯 Class start detected at line 56: struct javascript_action : tao::pegtl::nothing<Rule> {};
🎯 Single-line class detected, processing members inline
📝 Class body: ''
🔍 Processing segments from body: ''
🔍 Processing class: 'JavaScriptPEGTLAnalyzer'
🎯 Found correct class 'JavaScriptPEGTLAnalyzer' at line 547
✅ Corrected start_line for 'JavaScriptPEGTLAnalyzer': 547
🔍 Scanning lines 547-1402 for class 'JavaScriptPEGTLAnalyzer'
🎯 Class start detected at line 547: class JavaScriptPEGTLAnalyzer : public BaseAnalyzer {
📄 Line 548 (in_class=1, brace_depth=1): public:
📄 Line 549 (in_class=1, brace_depth=1):     JavaScriptPEGTLAnalyzer() = default;
📄 Line 550 (in_class=1, brace_depth=1):     ~JavaScriptPEGTLAnalyzer() = default;
📄 Line 551 (in_class=1, brace_depth=1):     
📄 Line 552 (in_class=1, brace_depth=1):     Language get_language() const override {
📄 Line 553 (in_class=1, brace_depth=2):         return Language::JAVASCRIPT;
📄 Line 554 (in_class=1, brace_depth=2):     }
📄 Line 555 (in_class=1, brace_depth=1):     
📄 Line 556 (in_class=1, brace_depth=1):     std::string get_language_name() const override {
📄 Line 557 (in_class=1, brace_depth=2):         return "JavaScript (PEGTL)";
📄 Line 558 (in_class=1, brace_depth=2):     }
📄 Line 559 (in_class=1, brace_depth=1):     
📄 Line 560 (in_class=1, brace_depth=1):     std::vector<std::string> get_supported_extensions() const override {
📄 Line 561 (in_class=1, brace_depth=2):         return {".js", ".mjs", ".jsx", ".cjs"};
📄 Line 562 (in_class=1, brace_depth=2):     }
📄 Line 563 (in_class=1, brace_depth=1):     
📄 Line 564 (in_class=1, brace_depth=1):     AnalysisResult analyze(const std::string& content, const std::string& filename) override {
📄 Line 565 (in_class=1, brace_depth=2):         AnalysisResult result;
🎯 Found member variable: result in class JavaScriptPEGTLAnalyzer at line 565
    📝 Line content: '        AnalysisResult result;'
📄 Line 566 (in_class=1, brace_depth=2):         
📄 Line 567 (in_class=1, brace_depth=2):         // ファイル情報設定
📄 Line 568 (in_class=1, brace_depth=2):         result.file_info.name = filename;
📄 Line 569 (in_class=1, brace_depth=2):         result.file_info.size_bytes = content.size();
📄 Line 570 (in_class=1, brace_depth=2):         result.language = Language::JAVASCRIPT;
📄 Line 571 (in_class=1, brace_depth=2):         
📄 Line 572 (in_class=1, brace_depth=2):         // PEGTL解析実行
📄 Line 573 (in_class=1, brace_depth=2):         try {
📄 Line 574 (in_class=1, brace_depth=3):             JavaScriptParseState state;
🎯 Found member variable: state in class JavaScriptPEGTLAnalyzer at line 574
    📝 Line content: '            JavaScriptParseState state;'
📄 Line 575 (in_class=1, brace_depth=3):             state.current_content = content;
📄 Line 576 (in_class=1, brace_depth=3):             
📄 Line 577 (in_class=1, brace_depth=3):             tao::pegtl::string_input input(content, filename);
📄 Line 578 (in_class=1, brace_depth=3):             bool success = tao::pegtl::parse<javascript::minimal_grammar::javascript_minimal, 
📄 Line 579 (in_class=1, brace_depth=3):                                           javascript_action>(input, state);
📄 Line 580 (in_class=1, brace_depth=3):             
📄 Line 581 (in_class=1, brace_depth=3):             // デバッグ: パース結果を強制確認
📄 Line 582 (in_class=1, brace_depth=3):             if (success) {
📄 Line 583 (in_class=1, brace_depth=4):                 // 解析結果をAnalysisResultに移動
📄 Line 584 (in_class=1, brace_depth=4):                 result.classes = std::move(state.classes);
📄 Line 585 (in_class=1, brace_depth=4):                 result.functions = std::move(state.functions);
📄 Line 586 (in_class=1, brace_depth=4):                 result.imports = std::move(state.imports);
📄 Line 587 (in_class=1, brace_depth=4):                 result.exports = std::move(state.exports);
📄 Line 588 (in_class=1, brace_depth=4):                 
📄 Line 589 (in_class=1, brace_depth=4):                 // デバッグ出力
📄 Line 590 (in_class=1, brace_depth=4):                 //// std::cerr << "[DEBUG] Functions found: " << result.functions.size() << std::endl;
📄 Line 591 (in_class=1, brace_depth=4):                 //for (const auto& f : result.functions) {
📄 Line 592 (in_class=1, brace_depth=5):                 //    std::cerr << "  - " << f.name << " at line " << f.start_line << std::endl;
📄 Line 593 (in_class=1, brace_depth=5):                 //}
📄 Line 594 (in_class=1, brace_depth=4):             }
📄 Line 595 (in_class=1, brace_depth=3):             
📄 Line 596 (in_class=1, brace_depth=3):             // デバッグコード削除済み
📄 Line 597 (in_class=1, brace_depth=3):             
📄 Line 598 (in_class=1, brace_depth=3):         } catch (const tao::pegtl::parse_error& e) {
📄 Line 599 (in_class=1, brace_depth=3):             // パースエラーは警告として記録（完全失敗ではない）
📄 Line 600 (in_class=1, brace_depth=3):             // TODO: エラー記録方法を検討
📄 Line 601 (in_class=1, brace_depth=3):             // result.file_info.notes = "PEGTL parse warning: " + std::string(e.what());
📄 Line 602 (in_class=1, brace_depth=3):         }
📄 Line 603 (in_class=1, brace_depth=2):         
📄 Line 604 (in_class=1, brace_depth=2):         // 複雑度計算（既存ロジック流用）
📄 Line 605 (in_class=1, brace_depth=2):         result.complexity = calculate_javascript_complexity(content);
📄 Line 606 (in_class=1, brace_depth=2):         
📄 Line 607 (in_class=1, brace_depth=2):         // 🔍 JavaScriptメンバ変数検出（C++成功パターン移植）
📄 Line 608 (in_class=1, brace_depth=2):         detect_member_variables(result, content);
📄 Line 609 (in_class=1, brace_depth=2):         
📄 Line 610 (in_class=1, brace_depth=2):         // 🚀 ハイブリッド戦略: 統計整合性チェック + 行ベース補完
📄 Line 611 (in_class=1, brace_depth=2):         if (needs_line_based_fallback(result, content)) {
📄 Line 612 (in_class=1, brace_depth=3):             apply_line_based_analysis(result, content, filename);
📄 Line 613 (in_class=1, brace_depth=3):         }
📄 Line 614 (in_class=1, brace_depth=2):         
📄 Line 615 (in_class=1, brace_depth=2):         // 統計更新
📄 Line 616 (in_class=1, brace_depth=2):         result.update_statistics();
📄 Line 617 (in_class=1, brace_depth=2):         
📄 Line 618 (in_class=1, brace_depth=2):         return result;
🎯 Found member variable: result in class JavaScriptPEGTLAnalyzer at line 618
    📝 Line content: '        return result;'
📄 Line 619 (in_class=1, brace_depth=2):     }
📄 Line 620 (in_class=1, brace_depth=1): 
📄 Line 621 (in_class=1, brace_depth=1): private:
📄 Line 622 (in_class=1, brace_depth=1):     // 🔍 JavaScriptメンバ変数検出（C++成功パターン移植）
📄 Line 623 (in_class=1, brace_depth=1):     void detect_member_variables(AnalysisResult& result, const std::string& content) {
📄 Line 624 (in_class=1, brace_depth=2):         std::istringstream stream(content);
📄 Line 625 (in_class=1, brace_depth=2):         std::string line;
🎯 Found member variable: line in class JavaScriptPEGTLAnalyzer at line 625
    📝 Line content: '        std::string line;'
📄 Line 626 (in_class=1, brace_depth=2):         size_t line_number = 0;
🎯 Found member variable: line_number in class JavaScriptPEGTLAnalyzer at line 626
    📝 Line content: '        size_t line_number = 0;'
📄 Line 627 (in_class=1, brace_depth=2):         
📄 Line 628 (in_class=1, brace_depth=2):         // 現在解析中のクラス情報
📄 Line 629 (in_class=1, brace_depth=2):         std::string current_class;
🎯 Found member variable: current_class in class JavaScriptPEGTLAnalyzer at line 629
    📝 Line content: '        std::string current_class;'
📄 Line 630 (in_class=1, brace_depth=2):         size_t current_class_index = 0;
🎯 Found member variable: current_class_index in class JavaScriptPEGTLAnalyzer at line 630
    📝 Line content: '        size_t current_class_index = 0;'
📄 Line 631 (in_class=1, brace_depth=2):         bool in_constructor = false;
🎯 Found member variable: in_constructor in class JavaScriptPEGTLAnalyzer at line 631
    📝 Line content: '        bool in_constructor = false;'
📄 Line 632 (in_class=1, brace_depth=2):         size_t class_brace_depth = 0;
🎯 Found member variable: class_brace_depth in class JavaScriptPEGTLAnalyzer at line 632
    📝 Line content: '        size_t class_brace_depth = 0;'
📄 Line 633 (in_class=1, brace_depth=2):         size_t current_brace_depth = 0;
🎯 Found member variable: current_brace_depth in class JavaScriptPEGTLAnalyzer at line 633
    📝 Line content: '        size_t current_brace_depth = 0;'
📄 Line 634 (in_class=1, brace_depth=2):         
📄 Line 635 (in_class=1, brace_depth=2):         while (std::getline(stream, line)) {
📄 Line 636 (in_class=1, brace_depth=3):             line_number++;
📄 Line 637 (in_class=1, brace_depth=3):             
📄 Line 638 (in_class=1, brace_depth=3):             // ブレース深度追跡
📄 Line 639 (in_class=1, brace_depth=3):             for (char c : line) {
📄 Line 640 (in_class=1, brace_depth=4):                 if (c == '{') {
📄 Line 641 (in_class=1, brace_depth=6):                     current_brace_depth++;
📄 Line 642 (in_class=1, brace_depth=6):                 } else if (c == '}') {
📄 Line 643 (in_class=1, brace_depth=5):                     if (current_brace_depth > 0) current_brace_depth--;
📄 Line 644 (in_class=1, brace_depth=5):                     if (current_brace_depth <= class_brace_depth && !current_class.empty()) {
📄 Line 645 (in_class=1, brace_depth=6):                         // クラス終了
📄 Line 646 (in_class=1, brace_depth=6):                         current_class.clear();
📄 Line 647 (in_class=1, brace_depth=6):                         in_constructor = false;
📄 Line 648 (in_class=1, brace_depth=6):                         class_brace_depth = 0;
📄 Line 649 (in_class=1, brace_depth=6):                     }
📄 Line 650 (in_class=1, brace_depth=5):                 }
📄 Line 651 (in_class=1, brace_depth=4):             }
📄 Line 652 (in_class=1, brace_depth=3):             
📄 Line 653 (in_class=1, brace_depth=3):             // クラス開始検出
📄 Line 654 (in_class=1, brace_depth=3):             std::regex class_pattern(R"(^\s*(?:export\s+)?class\s+(\w+))");
📄 Line 655 (in_class=1, brace_depth=3):             std::smatch class_match;
🎯 Found member variable: class_match in class JavaScriptPEGTLAnalyzer at line 655
    📝 Line content: '            std::smatch class_match;'
📄 Line 656 (in_class=1, brace_depth=3):             if (std::regex_search(line, class_match, class_pattern)) {
📄 Line 657 (in_class=1, brace_depth=4):                 current_class = class_match[1].str();
📄 Line 658 (in_class=1, brace_depth=4):                 class_brace_depth = current_brace_depth;
📄 Line 659 (in_class=1, brace_depth=4):                 
📄 Line 660 (in_class=1, brace_depth=4):                 // 既存のクラス情報を見つける
📄 Line 661 (in_class=1, brace_depth=4):                 for (size_t i = 0; i < result.classes.size(); i++) {
📄 Line 662 (in_class=1, brace_depth=5):                     if (result.classes[i].name == current_class) {
📄 Line 663 (in_class=1, brace_depth=6):                         current_class_index = i;
📄 Line 664 (in_class=1, brace_depth=6):                         break;
📄 Line 665 (in_class=1, brace_depth=6):                     }
📄 Line 666 (in_class=1, brace_depth=5):                 }
📄 Line 667 (in_class=1, brace_depth=4):             }
📄 Line 668 (in_class=1, brace_depth=3):             
📄 Line 669 (in_class=1, brace_depth=3):             // コンストラクタ検出
📄 Line 670 (in_class=1, brace_depth=3):             if (!current_class.empty()) {
📄 Line 671 (in_class=1, brace_depth=4):                 std::regex constructor_pattern(R"(^\s*constructor\s*\()");
📄 Line 672 (in_class=1, brace_depth=4):                 if (std::regex_search(line, constructor_pattern)) {
📄 Line 673 (in_class=1, brace_depth=5):                     in_constructor = true;
📄 Line 674 (in_class=1, brace_depth=5):                 }
📄 Line 675 (in_class=1, brace_depth=4):             }
📄 Line 676 (in_class=1, brace_depth=3):             
📄 Line 677 (in_class=1, brace_depth=3):             // JavaScriptメンバ変数パターン検出
📄 Line 678 (in_class=1, brace_depth=3):             if (!current_class.empty() && current_class_index < result.classes.size()) {
📄 Line 679 (in_class=1, brace_depth=4):                 detect_javascript_member_patterns(line, line_number, result.classes[current_class_index], in_constructor);
📄 Line 680 (in_class=1, brace_depth=4):             }
📄 Line 681 (in_class=1, brace_depth=3):         }
📄 Line 682 (in_class=1, brace_depth=2):     }
📄 Line 683 (in_class=1, brace_depth=1):     
📄 Line 684 (in_class=1, brace_depth=1):     // JavaScriptメンバ変数パターン検出
📄 Line 685 (in_class=1, brace_depth=1):     void detect_javascript_member_patterns(const std::string& line, size_t line_number, 
📄 Line 686 (in_class=1, brace_depth=1):                                           ClassInfo& class_info, bool in_constructor) {
📄 Line 687 (in_class=1, brace_depth=2):         std::smatch match;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 687
    📝 Line content: '        std::smatch match;'
📄 Line 688 (in_class=1, brace_depth=2):         
📄 Line 689 (in_class=1, brace_depth=2):         // パターン1: this.property = value (コンストラクタやメソッド内)
📄 Line 690 (in_class=1, brace_depth=2):         std::regex this_property_pattern(R"(this\.(\w+)\s*=)");
📄 Line 691 (in_class=1, brace_depth=2):         auto this_begin = std::sregex_iterator(line.begin(), line.end(), this_property_pattern);
🎯 Found member variable: this_begin in class JavaScriptPEGTLAnalyzer at line 691
    📝 Line content: '        auto this_begin = std::sregex_iterator(line.begin(), line.end(), this_property_pattern);'
📄 Line 692 (in_class=1, brace_depth=2):         auto this_end = std::sregex_iterator();
🎯 Found member variable: this_end in class JavaScriptPEGTLAnalyzer at line 692
    📝 Line content: '        auto this_end = std::sregex_iterator();'
📄 Line 693 (in_class=1, brace_depth=2):         
📄 Line 694 (in_class=1, brace_depth=2):         for (std::sregex_iterator i = this_begin; i != this_end; ++i) {
📄 Line 695 (in_class=1, brace_depth=3):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 695
    📝 Line content: '            std::smatch match = *i;'
📄 Line 696 (in_class=1, brace_depth=3):             std::string property_name = match[1].str();
🎯 Found member variable: property_name in class JavaScriptPEGTLAnalyzer at line 696
    📝 Line content: '            std::string property_name = match[1].str();'
📄 Line 697 (in_class=1, brace_depth=3):             
📄 Line 698 (in_class=1, brace_depth=3):             // 重複チェック
📄 Line 699 (in_class=1, brace_depth=3):             bool already_exists = false;
🎯 Found member variable: already_exists in class JavaScriptPEGTLAnalyzer at line 699
    📝 Line content: '            bool already_exists = false;'
📄 Line 700 (in_class=1, brace_depth=3):             for (const auto& member : class_info.member_variables) {
📄 Line 701 (in_class=1, brace_depth=4):                 if (member.name == property_name) {
📄 Line 702 (in_class=1, brace_depth=5):                     already_exists = true;
📄 Line 703 (in_class=1, brace_depth=5):                     break;
📄 Line 704 (in_class=1, brace_depth=5):                 }
📄 Line 705 (in_class=1, brace_depth=4):             }
📄 Line 706 (in_class=1, brace_depth=3):             
📄 Line 707 (in_class=1, brace_depth=3):             if (!already_exists) {
📄 Line 708 (in_class=1, brace_depth=4):                 MemberVariable member;
🎯 Found member variable: member in class JavaScriptPEGTLAnalyzer at line 708
    📝 Line content: '                MemberVariable member;'
📄 Line 709 (in_class=1, brace_depth=4):                 member.name = property_name;
📄 Line 710 (in_class=1, brace_depth=4):                 member.type = "any"; // JavaScriptは動的型付け
📄 Line 711 (in_class=1, brace_depth=4):                 member.declaration_line = line_number;
📄 Line 712 (in_class=1, brace_depth=4):                 member.access_modifier = "public"; // JavaScriptのthis.propertyは基本public
📄 Line 713 (in_class=1, brace_depth=4):                 
📄 Line 714 (in_class=1, brace_depth=4):                 // 値から型を推定
📄 Line 715 (in_class=1, brace_depth=4):                 if (line.find("= new ") != std::string::npos) {
📄 Line 716 (in_class=1, brace_depth=5):                     member.type = "object";
📄 Line 717 (in_class=1, brace_depth=5):                 } else if (line.find("= []") != std::string::npos) {
📄 Line 718 (in_class=1, brace_depth=5):                     member.type = "array";
📄 Line 719 (in_class=1, brace_depth=5):                 } else if (line.find("= {}") != std::string::npos) {
📄 Line 720 (in_class=1, brace_depth=5):                     member.type = "object";
📄 Line 721 (in_class=1, brace_depth=5):                 } else if (line.find("= true") != std::string::npos || line.find("= false") != std::string::npos) {
📄 Line 722 (in_class=1, brace_depth=5):                     member.type = "boolean";
📄 Line 723 (in_class=1, brace_depth=5):                 } else if (std::regex_search(line, std::regex(R"(=\s*\d+)"))) {
📄 Line 724 (in_class=1, brace_depth=5):                     member.type = "number";
📄 Line 725 (in_class=1, brace_depth=5):                 } else if (std::regex_search(line, std::regex(R"(=\s*['""])"))) {
📄 Line 726 (in_class=1, brace_depth=5):                     member.type = "string";
📄 Line 727 (in_class=1, brace_depth=5):                 }
📄 Line 728 (in_class=1, brace_depth=4):                 
📄 Line 729 (in_class=1, brace_depth=4):                 class_info.member_variables.push_back(member);
📄 Line 730 (in_class=1, brace_depth=4):             }
📄 Line 731 (in_class=1, brace_depth=3):         }
📄 Line 732 (in_class=1, brace_depth=2):         
📄 Line 733 (in_class=1, brace_depth=2):         // パターン2: ES2022プライベートフィールド #privateField = value
📄 Line 734 (in_class=1, brace_depth=2):         std::regex private_field_pattern(R"(^\s*#(\w+)\s*=)");
📄 Line 735 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, private_field_pattern)) {
📄 Line 736 (in_class=1, brace_depth=3):             std::string field_name = match[1].str();
🎯 Found member variable: field_name in class JavaScriptPEGTLAnalyzer at line 736
    📝 Line content: '            std::string field_name = match[1].str();'
📄 Line 737 (in_class=1, brace_depth=3):             
📄 Line 738 (in_class=1, brace_depth=3):             MemberVariable member;
🎯 Found member variable: member in class JavaScriptPEGTLAnalyzer at line 738
    📝 Line content: '            MemberVariable member;'
📄 Line 739 (in_class=1, brace_depth=3):             member.name = "#" + field_name; // プライベートフィールドは#付きで保存
📄 Line 740 (in_class=1, brace_depth=3):             member.type = "any";
📄 Line 741 (in_class=1, brace_depth=3):             member.declaration_line = line_number;
📄 Line 742 (in_class=1, brace_depth=3):             member.access_modifier = "private";
📄 Line 743 (in_class=1, brace_depth=3):             member.is_static = false;
📄 Line 744 (in_class=1, brace_depth=3):             
📄 Line 745 (in_class=1, brace_depth=3):             class_info.member_variables.push_back(member);
📄 Line 746 (in_class=1, brace_depth=3):         }
📄 Line 747 (in_class=1, brace_depth=2):         
📄 Line 748 (in_class=1, brace_depth=2):         // パターン3: ES6クラスフィールド property = value
📄 Line 749 (in_class=1, brace_depth=2):         std::regex class_field_pattern(R"(^\s*(\w+)\s*=)");
📄 Line 750 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, class_field_pattern) && 
📄 Line 751 (in_class=1, brace_depth=2):             !in_constructor && // コンストラクタ内のthis.propertyと区別
📄 Line 752 (in_class=1, brace_depth=2):             line.find("this.") == std::string::npos && // this.propertyではない
📄 Line 753 (in_class=1, brace_depth=2):             line.find("function") == std::string::npos && // 関数定義ではない
📄 Line 754 (in_class=1, brace_depth=2):             line.find("const") == std::string::npos && // const宣言ではない
📄 Line 755 (in_class=1, brace_depth=2):             line.find("let") == std::string::npos && // let宣言ではない
📄 Line 756 (in_class=1, brace_depth=2):             line.find("var") == std::string::npos) { // var宣言ではない
📄 Line 757 (in_class=1, brace_depth=3):             
📄 Line 758 (in_class=1, brace_depth=3):             std::string field_name = match[1].str();
🎯 Found member variable: field_name in class JavaScriptPEGTLAnalyzer at line 758
    📝 Line content: '            std::string field_name = match[1].str();'
📄 Line 759 (in_class=1, brace_depth=3):             
📄 Line 760 (in_class=1, brace_depth=3):             MemberVariable member;
🎯 Found member variable: member in class JavaScriptPEGTLAnalyzer at line 760
    📝 Line content: '            MemberVariable member;'
📄 Line 761 (in_class=1, brace_depth=3):             member.name = field_name;
📄 Line 762 (in_class=1, brace_depth=3):             member.type = "any";
📄 Line 763 (in_class=1, brace_depth=3):             member.declaration_line = line_number;
📄 Line 764 (in_class=1, brace_depth=3):             member.access_modifier = "public";
📄 Line 765 (in_class=1, brace_depth=3):             member.is_static = false;
📄 Line 766 (in_class=1, brace_depth=3):             
📄 Line 767 (in_class=1, brace_depth=3):             class_info.member_variables.push_back(member);
📄 Line 768 (in_class=1, brace_depth=3):         }
📄 Line 769 (in_class=1, brace_depth=2):         
📄 Line 770 (in_class=1, brace_depth=2):         // パターン4: 静的プロパティ static property = value
📄 Line 771 (in_class=1, brace_depth=2):         std::regex static_property_pattern(R"(^\s*static\s+(\w+)\s*=)");
📄 Line 772 (in_class=1, brace_depth=2):         if (std::regex_search(line, match, static_property_pattern)) {
📄 Line 773 (in_class=1, brace_depth=3):             std::string property_name = match[1].str();
🎯 Found member variable: property_name in class JavaScriptPEGTLAnalyzer at line 773
    📝 Line content: '            std::string property_name = match[1].str();'
📄 Line 774 (in_class=1, brace_depth=3):             
📄 Line 775 (in_class=1, brace_depth=3):             MemberVariable member;
🎯 Found member variable: member in class JavaScriptPEGTLAnalyzer at line 775
    📝 Line content: '            MemberVariable member;'
📄 Line 776 (in_class=1, brace_depth=3):             member.name = property_name;
📄 Line 777 (in_class=1, brace_depth=3):             member.type = "any";
📄 Line 778 (in_class=1, brace_depth=3):             member.declaration_line = line_number;
📄 Line 779 (in_class=1, brace_depth=3):             member.access_modifier = "public";
📄 Line 780 (in_class=1, brace_depth=3):             member.is_static = true;
📄 Line 781 (in_class=1, brace_depth=3):             
📄 Line 782 (in_class=1, brace_depth=3):             class_info.member_variables.push_back(member);
📄 Line 783 (in_class=1, brace_depth=3):         }
📄 Line 784 (in_class=1, brace_depth=2):     }
📄 Line 785 (in_class=1, brace_depth=1): 
📄 Line 786 (in_class=1, brace_depth=1):     // 複雑度計算（C#成功パターン準拠）
📄 Line 787 (in_class=1, brace_depth=1):     ComplexityInfo calculate_javascript_complexity(const std::string& content) {
📄 Line 788 (in_class=1, brace_depth=2):         ComplexityInfo complexity;
🎯 Found member variable: complexity in class JavaScriptPEGTLAnalyzer at line 788
    📝 Line content: '        ComplexityInfo complexity;'
📄 Line 789 (in_class=1, brace_depth=2):         complexity.cyclomatic_complexity = 1;
📄 Line 790 (in_class=1, brace_depth=2):         
📄 Line 791 (in_class=1, brace_depth=2):         // JavaScript固有の複雑度キーワード
📄 Line 792 (in_class=1, brace_depth=2):         std::vector<std::string> complexity_keywords = {
📄 Line 793 (in_class=1, brace_depth=3):             "if ", "else if", "else ", "for ", "while ", "do ",
📄 Line 794 (in_class=1, brace_depth=3):             "switch ", "case ", "catch ", "&&", "||", "? ",
📄 Line 795 (in_class=1, brace_depth=3):             ".then(", ".catch(", "async ", "await "
📄 Line 796 (in_class=1, brace_depth=3):         };
📄 Line 797 (in_class=1, brace_depth=2):         
📄 Line 798 (in_class=1, brace_depth=2):         for (const auto& keyword : complexity_keywords) {
📄 Line 799 (in_class=1, brace_depth=3):             size_t pos = 0;
🎯 Found member variable: pos in class JavaScriptPEGTLAnalyzer at line 799
    📝 Line content: '            size_t pos = 0;'
📄 Line 800 (in_class=1, brace_depth=3):             while ((pos = content.find(keyword, pos)) != std::string::npos) {
📄 Line 801 (in_class=1, brace_depth=4):                 complexity.cyclomatic_complexity++;
📄 Line 802 (in_class=1, brace_depth=4):                 pos += keyword.length();
📄 Line 803 (in_class=1, brace_depth=4):             }
📄 Line 804 (in_class=1, brace_depth=3):         }
📄 Line 805 (in_class=1, brace_depth=2):         
📄 Line 806 (in_class=1, brace_depth=2):         // ネスト深度計算
📄 Line 807 (in_class=1, brace_depth=2):         complexity.max_nesting_depth = 0;
📄 Line 808 (in_class=1, brace_depth=2):         uint32_t current_depth = 0;
🎯 Found member variable: current_depth in class JavaScriptPEGTLAnalyzer at line 808
    📝 Line content: '        uint32_t current_depth = 0;'
📄 Line 809 (in_class=1, brace_depth=2):         
📄 Line 810 (in_class=1, brace_depth=2):         for (char c : content) {
📄 Line 811 (in_class=1, brace_depth=3):             if (c == '{') {
📄 Line 812 (in_class=1, brace_depth=5):                 current_depth++;
📄 Line 813 (in_class=1, brace_depth=5):                 if (current_depth > complexity.max_nesting_depth) {
📄 Line 814 (in_class=1, brace_depth=6):                     complexity.max_nesting_depth = current_depth;
📄 Line 815 (in_class=1, brace_depth=6):                 }
📄 Line 816 (in_class=1, brace_depth=5):             } else if (c == '}' && current_depth > 0) {
📄 Line 817 (in_class=1, brace_depth=4):                 current_depth--;
📄 Line 818 (in_class=1, brace_depth=4):             }
📄 Line 819 (in_class=1, brace_depth=3):         }
📄 Line 820 (in_class=1, brace_depth=2):         
📄 Line 821 (in_class=1, brace_depth=2):         complexity.update_rating();
📄 Line 822 (in_class=1, brace_depth=2):         return complexity;
🎯 Found member variable: complexity in class JavaScriptPEGTLAnalyzer at line 822
    📝 Line content: '        return complexity;'
📄 Line 823 (in_class=1, brace_depth=2):     }
📄 Line 824 (in_class=1, brace_depth=1):     
📄 Line 825 (in_class=1, brace_depth=1):     // 🚀 ハイブリッド戦略: 統計整合性チェック
📄 Line 826 (in_class=1, brace_depth=1):     bool needs_line_based_fallback(const AnalysisResult& result, const std::string& content) {
📄 Line 827 (in_class=1, brace_depth=2):         // 戦略ドキュメント通り: 複雑度 vs 検出数の妖当性検証
📄 Line 828 (in_class=1, brace_depth=2):         uint32_t complexity = result.complexity.cyclomatic_complexity;
🎯 Found member variable: complexity in class JavaScriptPEGTLAnalyzer at line 828
    📝 Line content: '        uint32_t complexity = result.complexity.cyclomatic_complexity;'
📄 Line 829 (in_class=1, brace_depth=2):         size_t detected_functions = result.functions.size();
🎯 Found member variable: detected_functions in class JavaScriptPEGTLAnalyzer at line 829
    📝 Line content: '        size_t detected_functions = result.functions.size();'
📄 Line 830 (in_class=1, brace_depth=2):         size_t detected_classes = result.classes.size();
🎯 Found member variable: detected_classes in class JavaScriptPEGTLAnalyzer at line 830
    📝 Line content: '        size_t detected_classes = result.classes.size();'
📄 Line 831 (in_class=1, brace_depth=2):         
📄 Line 832 (in_class=1, brace_depth=2):         // 経験的闾値: 複雑度100以上で関数検出が10未満は明らかにおかしい
📄 Line 833 (in_class=1, brace_depth=2):         if (complexity > 100 && detected_functions < 10) {
📄 Line 834 (in_class=1, brace_depth=3):             return true;
🎯 Found member variable: true in class JavaScriptPEGTLAnalyzer at line 834
    📝 Line content: '            return true;'
📄 Line 835 (in_class=1, brace_depth=3):         }
📄 Line 836 (in_class=1, brace_depth=2):         
📄 Line 837 (in_class=1, brace_depth=2):         // 複雑度500以上で関数検出0は絶対におかしい（lodashケース）
📄 Line 838 (in_class=1, brace_depth=2):         if (complexity > 500 && detected_functions == 0) {
📄 Line 839 (in_class=1, brace_depth=3):             return true;
🎯 Found member variable: true in class JavaScriptPEGTLAnalyzer at line 839
    📝 Line content: '            return true;'
📄 Line 840 (in_class=1, brace_depth=3):         }
📄 Line 841 (in_class=1, brace_depth=2):         
📄 Line 842 (in_class=1, brace_depth=2):         // クラスがあるのに関数が少ない場合（class methodsが検出されていない可能性）
📄 Line 843 (in_class=1, brace_depth=2):         if (detected_classes > 0 && detected_functions < 5) {
📄 Line 844 (in_class=1, brace_depth=3):             // std::cerr << "[DEBUG] Class method fallback triggered: classes=" << detected_classes << ", functions=" << detected_functions << std::endl;
📄 Line 845 (in_class=1, brace_depth=3):             return true;
🎯 Found member variable: true in class JavaScriptPEGTLAnalyzer at line 845
    📝 Line content: '            return true;'
📄 Line 846 (in_class=1, brace_depth=3):         }
📄 Line 847 (in_class=1, brace_depth=2):         
📄 Line 848 (in_class=1, brace_depth=2):         // コンテンツにIIFEパターンがある場合もフォールバック
📄 Line 849 (in_class=1, brace_depth=2):         if (content.find(";(function()") != std::string::npos || 
📄 Line 850 (in_class=1, brace_depth=2):             content.find("(function(){") != std::string::npos) {
📄 Line 851 (in_class=1, brace_depth=4):             return true;
🎯 Found member variable: true in class JavaScriptPEGTLAnalyzer at line 851
    📝 Line content: '            return true;'
📄 Line 852 (in_class=1, brace_depth=4):         }
📄 Line 853 (in_class=1, brace_depth=3):         
📄 Line 854 (in_class=1, brace_depth=3):         return false;
🎯 Found member variable: false in class JavaScriptPEGTLAnalyzer at line 854
    📝 Line content: '        return false;'
📄 Line 855 (in_class=1, brace_depth=3):     }
📄 Line 856 (in_class=1, brace_depth=2):     
📄 Line 857 (in_class=1, brace_depth=2):     // 🚀 JavaScript世界最強戦略: 自動最適化ハイブリッド解析（TypeScript成功パターン移植）
📄 Line 858 (in_class=1, brace_depth=2):     void apply_line_based_analysis(AnalysisResult& result, const std::string& content, const std::string& /* filename */) {
📄 Line 859 (in_class=1, brace_depth=3):         // 🎯 ファイルサイズ検出と戦略決定
📄 Line 860 (in_class=1, brace_depth=3):         std::vector<std::string> all_lines;
🎯 Found member variable: all_lines in class JavaScriptPEGTLAnalyzer at line 860
    📝 Line content: '        std::vector<std::string> all_lines;'
📄 Line 861 (in_class=1, brace_depth=3):         std::istringstream stream(content);
📄 Line 862 (in_class=1, brace_depth=3):         std::string line;
🎯 Found member variable: line in class JavaScriptPEGTLAnalyzer at line 862
    📝 Line content: '        std::string line;'
📄 Line 863 (in_class=1, brace_depth=3):         while (std::getline(stream, line)) {
📄 Line 864 (in_class=1, brace_depth=4):             all_lines.push_back(line);
📄 Line 865 (in_class=1, brace_depth=4):         }
📄 Line 866 (in_class=1, brace_depth=3):         
📄 Line 867 (in_class=1, brace_depth=3):         const size_t total_lines = all_lines.size();
🎯 Found member variable: total_lines in class JavaScriptPEGTLAnalyzer at line 867
    📝 Line content: '        const size_t total_lines = all_lines.size();'
📄 Line 868 (in_class=1, brace_depth=3):         const bool use_full_analysis = total_lines < 15000;     // JavaScript特化調整: 15K行未満で全機能
🎯 Found member variable: use_full_analysis in class JavaScriptPEGTLAnalyzer at line 868
    📝 Line content: '        const bool use_full_analysis = total_lines < 15000;     // JavaScript特化調整: 15K行未満で全機能'
📄 Line 869 (in_class=1, brace_depth=3):         const bool use_sampling_mode = total_lines >= 15000 && total_lines < 40000;  // サンプリングモード
🎯 Found member variable: use_sampling_mode in class JavaScriptPEGTLAnalyzer at line 869
    📝 Line content: '        const bool use_sampling_mode = total_lines >= 15000 && total_lines < 40000;  // サンプリングモード'
📄 Line 870 (in_class=1, brace_depth=3):         
📄 Line 871 (in_class=1, brace_depth=3):         std::cerr << "📊 JavaScript解析開始: " << total_lines << "行検出" << std::endl;
📄 Line 872 (in_class=1, brace_depth=3):         
📄 Line 873 (in_class=1, brace_depth=3):         // 既存の関数名を記録（重複検出を防ぐ）
📄 Line 874 (in_class=1, brace_depth=3):         std::set<std::string> existing_functions;
🎯 Found member variable: existing_functions in class JavaScriptPEGTLAnalyzer at line 874
    📝 Line content: '        std::set<std::string> existing_functions;'
📄 Line 875 (in_class=1, brace_depth=3):         for (const auto& func : result.functions) {
📄 Line 876 (in_class=1, brace_depth=4):             existing_functions.insert(func.name);
📄 Line 877 (in_class=1, brace_depth=4):         }
📄 Line 878 (in_class=1, brace_depth=3):         
📄 Line 879 (in_class=1, brace_depth=3):         // 🕐 処理時間測定開始
📄 Line 880 (in_class=1, brace_depth=3):         auto analysis_start = std::chrono::high_resolution_clock::now();
🎯 Found member variable: analysis_start in class JavaScriptPEGTLAnalyzer at line 880
    📝 Line content: '        auto analysis_start = std::chrono::high_resolution_clock::now();'
📄 Line 881 (in_class=1, brace_depth=3):         size_t processed_lines = 0;
🎯 Found member variable: processed_lines in class JavaScriptPEGTLAnalyzer at line 881
    📝 Line content: '        size_t processed_lines = 0;'
📄 Line 882 (in_class=1, brace_depth=3):         
📄 Line 883 (in_class=1, brace_depth=3):         if (use_full_analysis) {
📄 Line 884 (in_class=1, brace_depth=4):             std::cerr << "🚀 通常モード: 全機能有効（JavaScript最高精度）" << std::endl;
📄 Line 885 (in_class=1, brace_depth=4):             // 通常モード：全行処理
📄 Line 886 (in_class=1, brace_depth=4):             for (size_t i = 0; i < all_lines.size(); i++) {
📄 Line 887 (in_class=1, brace_depth=5):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class JavaScriptPEGTLAnalyzer at line 887
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 888 (in_class=1, brace_depth=5):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class JavaScriptPEGTLAnalyzer at line 888
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 889 (in_class=1, brace_depth=5):                 
📄 Line 890 (in_class=1, brace_depth=5):                 extract_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 891 (in_class=1, brace_depth=5):                 processed_lines++;
📄 Line 892 (in_class=1, brace_depth=5):             }
📄 Line 893 (in_class=1, brace_depth=4):         } else if (use_sampling_mode) {
📄 Line 894 (in_class=1, brace_depth=4):             std::cerr << "🎲 サンプリングモード: 10行に1行処理（効率重視）" << std::endl;
📄 Line 895 (in_class=1, brace_depth=4):             // サンプリングモード：10行に1行だけ処理
📄 Line 896 (in_class=1, brace_depth=4):             for (size_t i = 0; i < all_lines.size(); i += 10) {
📄 Line 897 (in_class=1, brace_depth=5):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class JavaScriptPEGTLAnalyzer at line 897
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 898 (in_class=1, brace_depth=5):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class JavaScriptPEGTLAnalyzer at line 898
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 899 (in_class=1, brace_depth=5):                 
📄 Line 900 (in_class=1, brace_depth=5):                 extract_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 901 (in_class=1, brace_depth=5):                 processed_lines++;
📄 Line 902 (in_class=1, brace_depth=5):             }
📄 Line 903 (in_class=1, brace_depth=4):         } else {
📄 Line 904 (in_class=1, brace_depth=4):             std::cerr << "⚡ 高速モード: 基本検出のみ（大規模JS対応）" << std::endl;
📄 Line 905 (in_class=1, brace_depth=4):             // 高速モード：基本検出のみ
📄 Line 906 (in_class=1, brace_depth=4):             for (size_t i = 0; i < all_lines.size(); i++) {
📄 Line 907 (in_class=1, brace_depth=5):                 const std::string& current_line = all_lines[i];
🎯 Found member variable: current_line in class JavaScriptPEGTLAnalyzer at line 907
    📝 Line content: '                const std::string& current_line = all_lines[i];'
📄 Line 908 (in_class=1, brace_depth=5):                 size_t current_line_number = i + 1;
🎯 Found member variable: current_line_number in class JavaScriptPEGTLAnalyzer at line 908
    📝 Line content: '                size_t current_line_number = i + 1;'
📄 Line 909 (in_class=1, brace_depth=5):                 
📄 Line 910 (in_class=1, brace_depth=5):                 // 基本的な関数パターンのみ検出
📄 Line 911 (in_class=1, brace_depth=5):                 extract_basic_functions_from_line(current_line, current_line_number, result, existing_functions);
📄 Line 912 (in_class=1, brace_depth=5):                 processed_lines++;
📄 Line 913 (in_class=1, brace_depth=5):             }
📄 Line 914 (in_class=1, brace_depth=4):         }
📄 Line 915 (in_class=1, brace_depth=3):         
📄 Line 916 (in_class=1, brace_depth=3):         auto analysis_end = std::chrono::high_resolution_clock::now();
🎯 Found member variable: analysis_end in class JavaScriptPEGTLAnalyzer at line 916
    📝 Line content: '        auto analysis_end = std::chrono::high_resolution_clock::now();'
📄 Line 917 (in_class=1, brace_depth=3):         auto analysis_time = std::chrono::duration_cast<std::chrono::milliseconds>(analysis_end - analysis_start);
🎯 Found member variable: analysis_time in class JavaScriptPEGTLAnalyzer at line 917
    📝 Line content: '        auto analysis_time = std::chrono::duration_cast<std::chrono::milliseconds>(analysis_end - analysis_start);'
📄 Line 918 (in_class=1, brace_depth=3):         
📄 Line 919 (in_class=1, brace_depth=3):         std::cerr << "✅ JavaScript第1段階完了: " << processed_lines << "行処理 (" 
📄 Line 920 (in_class=1, brace_depth=3):                   << analysis_time.count() << "ms)" << std::endl;
📄 Line 921 (in_class=1, brace_depth=3):         
📄 Line 922 (in_class=1, brace_depth=3):         // 🚀 【JavaScriptコールバック地獄専用】無限ネスト掘削アタック開始！
📄 Line 923 (in_class=1, brace_depth=3):         if (use_full_analysis || use_sampling_mode) {
📄 Line 924 (in_class=1, brace_depth=4):             std::cerr << "🚀 【JavaScript専用】無限ネスト掘削アタック開始！（コールバック地獄対応版）" << std::endl;
📄 Line 925 (in_class=1, brace_depth=4):             size_t initial_function_count = result.functions.size();
🎯 Found member variable: initial_function_count in class JavaScriptPEGTLAnalyzer at line 925
    📝 Line content: '            size_t initial_function_count = result.functions.size();'
📄 Line 926 (in_class=1, brace_depth=4):             
📄 Line 927 (in_class=1, brace_depth=4):             // 関数範囲を特定してネスト検索
📄 Line 928 (in_class=1, brace_depth=4):             extract_nested_functions_recursively(result, all_lines, existing_functions);
📄 Line 929 (in_class=1, brace_depth=4):             
📄 Line 930 (in_class=1, brace_depth=4):             size_t nested_functions_found = result.functions.size() - initial_function_count;
🎯 Found member variable: nested_functions_found in class JavaScriptPEGTLAnalyzer at line 930
    📝 Line content: '            size_t nested_functions_found = result.functions.size() - initial_function_count;'
📄 Line 931 (in_class=1, brace_depth=4):             std::cerr << "🏆 JavaScript無限ネスト掘削アタック最終結果：" << nested_functions_found 
📄 Line 932 (in_class=1, brace_depth=4):                       << "個のネスト関数を発見！" << std::endl;
📄 Line 933 (in_class=1, brace_depth=4):         } else {
📄 Line 934 (in_class=1, brace_depth=4):             std::cerr << "⚡ 高速モード: ネスト掘削スキップ（大規模JS対応）" << std::endl;
📄 Line 935 (in_class=1, brace_depth=4):         }
📄 Line 936 (in_class=1, brace_depth=3):         
📄 Line 937 (in_class=1, brace_depth=3):         // 🏁 処理戦略のサマリー
📄 Line 938 (in_class=1, brace_depth=3):         if (!use_full_analysis && !use_sampling_mode) {
📄 Line 939 (in_class=1, brace_depth=4):             std::cerr << "\n📊 処理戦略: 大規模JSファイルモード（基本検出のみ）" << std::endl;
📄 Line 940 (in_class=1, brace_depth=4):         } else if (use_sampling_mode) {
📄 Line 941 (in_class=1, brace_depth=4):             std::cerr << "\n📊 処理戦略: サンプリングモード（10%処理）" << std::endl;
📄 Line 942 (in_class=1, brace_depth=4):         } else {
📄 Line 943 (in_class=1, brace_depth=4):             std::cerr << "\n📊 処理戦略: 通常モード（全機能有効）" << std::endl;
📄 Line 944 (in_class=1, brace_depth=4):         }
📄 Line 945 (in_class=1, brace_depth=3):     }
📄 Line 946 (in_class=1, brace_depth=2):     
📄 Line 947 (in_class=1, brace_depth=2):     // 行から関数を抽出
📄 Line 948 (in_class=1, brace_depth=2):     void extract_functions_from_line(const std::string& line, size_t line_number, 
📄 Line 949 (in_class=1, brace_depth=2):                                       AnalysisResult& result, std::set<std::string>& existing_functions) {
📄 Line 950 (in_class=1, brace_depth=3):         
📄 Line 951 (in_class=1, brace_depth=3):         // 制御構造キーワードフィルタリング 🔥 NEW!
📄 Line 952 (in_class=1, brace_depth=3):         static const std::set<std::string> control_keywords = {
📄 Line 953 (in_class=1, brace_depth=4):             "if", "else", "for", "while", "do", "switch", "case", "catch", 
📄 Line 954 (in_class=1, brace_depth=4):             "try", "finally", "return", "break", "continue", "throw", 
📄 Line 955 (in_class=1, brace_depth=4):             "typeof", "instanceof", "new", "delete", "var", "let", "const"
📄 Line 956 (in_class=1, brace_depth=4):         };
📄 Line 957 (in_class=1, brace_depth=3):         
📄 Line 958 (in_class=1, brace_depth=3):         auto is_control_keyword = [&](const std::string& name) {
📄 Line 959 (in_class=1, brace_depth=4):             return control_keywords.find(name) != control_keywords.end();
📄 Line 960 (in_class=1, brace_depth=4):         };
📄 Line 961 (in_class=1, brace_depth=3):         
📄 Line 962 (in_class=1, brace_depth=3):         // パターン1: function name(
📄 Line 963 (in_class=1, brace_depth=3):         std::regex function_pattern(R"(^\s*function\s+(\w+)\s*\()");
📄 Line 964 (in_class=1, brace_depth=3):         std::smatch match;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 964
    📝 Line content: '        std::smatch match;'
📄 Line 965 (in_class=1, brace_depth=3):         
📄 Line 966 (in_class=1, brace_depth=3):         if (std::regex_search(line, match, function_pattern)) {
📄 Line 967 (in_class=1, brace_depth=4):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 967
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 968 (in_class=1, brace_depth=4):             if (!is_control_keyword(func_name) && existing_functions.find(func_name) == existing_functions.end()) {  // 🔥 フィルタリング追加!
📄 Line 969 (in_class=1, brace_depth=5):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 969
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 970 (in_class=1, brace_depth=5):                 func_info.name = func_name;
📄 Line 971 (in_class=1, brace_depth=5):                 func_info.start_line = line_number;
📄 Line 972 (in_class=1, brace_depth=5):                 // func_info.is_fallback_detected = true;  // TODO: FunctionInfoにフィールド追加
📄 Line 973 (in_class=1, brace_depth=5):                 result.functions.push_back(func_info);
📄 Line 974 (in_class=1, brace_depth=5):                 existing_functions.insert(func_name);
📄 Line 975 (in_class=1, brace_depth=5):             }
📄 Line 976 (in_class=1, brace_depth=4):         }
📄 Line 977 (in_class=1, brace_depth=3):         
📄 Line 978 (in_class=1, brace_depth=3):         // パターン2: const name = function(
📄 Line 979 (in_class=1, brace_depth=3):         std::regex const_function_pattern(R"(^\s*(?:const|let|var)\s+(\w+)\s*=\s*function\s*\()");
📄 Line 980 (in_class=1, brace_depth=3):         if (std::regex_search(line, match, const_function_pattern)) {
📄 Line 981 (in_class=1, brace_depth=4):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 981
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 982 (in_class=1, brace_depth=4):             if (existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 983 (in_class=1, brace_depth=5):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 983
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 984 (in_class=1, brace_depth=5):                 func_info.name = func_name;
📄 Line 985 (in_class=1, brace_depth=5):                 func_info.start_line = line_number;
📄 Line 986 (in_class=1, brace_depth=5):                 // func_info.is_fallback_detected = true;
📄 Line 987 (in_class=1, brace_depth=5):                 result.functions.push_back(func_info);
📄 Line 988 (in_class=1, brace_depth=5):                 existing_functions.insert(func_name);
📄 Line 989 (in_class=1, brace_depth=5):             }
📄 Line 990 (in_class=1, brace_depth=4):         }
📄 Line 991 (in_class=1, brace_depth=3):         
📄 Line 992 (in_class=1, brace_depth=3):         // パターン3: const name = () =>
📄 Line 993 (in_class=1, brace_depth=3):         std::regex arrow_pattern(R"(^\s*(?:const|let|var)\s+(\w+)\s*=\s*\([^)]*\)\s*=>)");
📄 Line 994 (in_class=1, brace_depth=3):         if (std::regex_search(line, match, arrow_pattern)) {
📄 Line 995 (in_class=1, brace_depth=4):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 995
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 996 (in_class=1, brace_depth=4):             if (existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 997 (in_class=1, brace_depth=5):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 997
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 998 (in_class=1, brace_depth=5):                 func_info.name = func_name;
📄 Line 999 (in_class=1, brace_depth=5):                 func_info.start_line = line_number;
📄 Line 1000 (in_class=1, brace_depth=5):                 func_info.is_arrow_function = true;
📄 Line 1001 (in_class=1, brace_depth=5):                 // func_info.is_fallback_detected = true;
📄 Line 1002 (in_class=1, brace_depth=5):                 result.functions.push_back(func_info);
📄 Line 1003 (in_class=1, brace_depth=5):                 existing_functions.insert(func_name);
📄 Line 1004 (in_class=1, brace_depth=5):                 // std::cerr << "[DEBUG] Fallback found arrow function: " << func_name << " at line " << line_number << std::endl;
📄 Line 1005 (in_class=1, brace_depth=5):             }
📄 Line 1006 (in_class=1, brace_depth=4):         }
📄 Line 1007 (in_class=1, brace_depth=3):         
📄 Line 1008 (in_class=1, brace_depth=3):         // パターン4: class method - methodName() {
📄 Line 1009 (in_class=1, brace_depth=4):         std::regex class_method_pattern(R"(^\s*(\w+)\s*\(\s*[^)]*\s*\)\s*\{)");
📄 Line 1010 (in_class=1, brace_depth=5):         if (std::regex_search(line, match, class_method_pattern)) {
📄 Line 1011 (in_class=1, brace_depth=6):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class JavaScriptPEGTLAnalyzer at line 1011
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 1012 (in_class=1, brace_depth=6):             // constructorや制御構造は関数として扱わない 🔥 フィルタリング強化!
📄 Line 1013 (in_class=1, brace_depth=6):             if (method_name != "constructor" && !is_control_keyword(method_name) && 
📄 Line 1014 (in_class=1, brace_depth=6):                 existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 1015 (in_class=1, brace_depth=7):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1015
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1016 (in_class=1, brace_depth=7):                 func_info.name = method_name;
📄 Line 1017 (in_class=1, brace_depth=7):                 func_info.start_line = line_number;
📄 Line 1018 (in_class=1, brace_depth=7):                 func_info.metadata["is_class_method"] = "true";
📄 Line 1019 (in_class=1, brace_depth=7):                 result.functions.push_back(func_info);
📄 Line 1020 (in_class=1, brace_depth=7):                 existing_functions.insert(method_name);
📄 Line 1021 (in_class=1, brace_depth=7):                 // std::cerr << "[DEBUG] Fallback found class method: " << method_name << " at line " << line_number << std::endl;
📄 Line 1022 (in_class=1, brace_depth=7):             }
📄 Line 1023 (in_class=1, brace_depth=6):         }
📄 Line 1024 (in_class=1, brace_depth=5):         
📄 Line 1025 (in_class=1, brace_depth=5):         // パターン5: static class method - static methodName() {
📄 Line 1026 (in_class=1, brace_depth=6):         std::regex static_method_pattern(R"(^\s*static\s+(\w+)\s*\(\s*[^)]*\s*\)\s*\{)");
📄 Line 1027 (in_class=1, brace_depth=7):         if (std::regex_search(line, match, static_method_pattern)) {
📄 Line 1028 (in_class=1, brace_depth=8):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class JavaScriptPEGTLAnalyzer at line 1028
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 1029 (in_class=1, brace_depth=8):             if (existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 1030 (in_class=1, brace_depth=9):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1030
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1031 (in_class=1, brace_depth=9):                 func_info.name = method_name;
📄 Line 1032 (in_class=1, brace_depth=9):                 func_info.start_line = line_number;
📄 Line 1033 (in_class=1, brace_depth=9):                 func_info.metadata["is_class_method"] = "true";
📄 Line 1034 (in_class=1, brace_depth=9):                 func_info.metadata["is_static"] = "true";
📄 Line 1035 (in_class=1, brace_depth=9):                 result.functions.push_back(func_info);
📄 Line 1036 (in_class=1, brace_depth=9):                 existing_functions.insert(method_name);
📄 Line 1037 (in_class=1, brace_depth=9):                 // std::cerr << "[DEBUG] Fallback found static method: " << method_name << " at line " << line_number << std::endl;
📄 Line 1038 (in_class=1, brace_depth=9):             }
📄 Line 1039 (in_class=1, brace_depth=8):         }
📄 Line 1040 (in_class=1, brace_depth=7):         
📄 Line 1041 (in_class=1, brace_depth=7):         // パターン6: async function
📄 Line 1042 (in_class=1, brace_depth=7):         std::regex async_function_pattern(R"(^\s*async\s+function\s+(\w+)\s*\()");
📄 Line 1043 (in_class=1, brace_depth=7):         if (std::regex_search(line, match, async_function_pattern)) {
📄 Line 1044 (in_class=1, brace_depth=8):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 1044
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 1045 (in_class=1, brace_depth=8):             if (existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 1046 (in_class=1, brace_depth=9):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1046
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1047 (in_class=1, brace_depth=9):                 func_info.name = func_name;
📄 Line 1048 (in_class=1, brace_depth=9):                 func_info.start_line = line_number;
📄 Line 1049 (in_class=1, brace_depth=9):                 func_info.is_async = true;
📄 Line 1050 (in_class=1, brace_depth=9):                 result.functions.push_back(func_info);
📄 Line 1051 (in_class=1, brace_depth=9):                 existing_functions.insert(func_name);
📄 Line 1052 (in_class=1, brace_depth=9):                 // std::cerr << "[DEBUG] Fallback found async function: " << func_name << " at line " << line_number << std::endl;
📄 Line 1053 (in_class=1, brace_depth=9):             }
📄 Line 1054 (in_class=1, brace_depth=8):         }
📄 Line 1055 (in_class=1, brace_depth=7):         
📄 Line 1056 (in_class=1, brace_depth=7):         // 🔥 【JavaScript行レベル二重アタック】パターン8: ES2015オブジェクトメソッドショートハンド - method() { (TypeScript成功パターン移植)
📄 Line 1057 (in_class=1, brace_depth=8):         std::regex es2015_method_pattern(R"(^\s*(\w+)\s*\(\s*[^)]*\s*\)\s*\{)");
📄 Line 1058 (in_class=1, brace_depth=9):         if (std::regex_search(line, match, es2015_method_pattern)) {
📄 Line 1059 (in_class=1, brace_depth=10):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class JavaScriptPEGTLAnalyzer at line 1059
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 1060 (in_class=1, brace_depth=10):             // constructor、get、set、制御構造は除外
📄 Line 1061 (in_class=1, brace_depth=10):             if (method_name != "constructor" && method_name != "get" && method_name != "set" && 
📄 Line 1062 (in_class=1, brace_depth=10):                 !is_control_keyword(method_name) && existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 1063 (in_class=1, brace_depth=11):                 // クラス内かオブジェクト内かを判定（簡易版）
📄 Line 1064 (in_class=1, brace_depth=11):                 bool is_likely_method = (line.find("class") == std::string::npos) && 
📄 Line 1065 (in_class=1, brace_depth=11):                                        (line.find("function") == std::string::npos);
📄 Line 1066 (in_class=1, brace_depth=11):                 if (is_likely_method) {
📄 Line 1067 (in_class=1, brace_depth=12):                     FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1067
    📝 Line content: '                    FunctionInfo func_info;'
📄 Line 1068 (in_class=1, brace_depth=12):                     func_info.name = method_name;
📄 Line 1069 (in_class=1, brace_depth=12):                     func_info.start_line = line_number;
📄 Line 1070 (in_class=1, brace_depth=12):                     func_info.metadata["is_es2015_method"] = "true";
📄 Line 1071 (in_class=1, brace_depth=12):                     func_info.metadata["pattern_type"] = "shorthand_method";
📄 Line 1072 (in_class=1, brace_depth=12):                     result.functions.push_back(func_info);
📄 Line 1073 (in_class=1, brace_depth=12):                     existing_functions.insert(method_name);
📄 Line 1074 (in_class=1, brace_depth=12):                     // std::cerr << "[DEBUG] 🔥 ES2015 method shorthand: " << method_name << " at line " << line_number << std::endl;
📄 Line 1075 (in_class=1, brace_depth=12):                 }
📄 Line 1076 (in_class=1, brace_depth=11):             }
📄 Line 1077 (in_class=1, brace_depth=10):         }
📄 Line 1078 (in_class=1, brace_depth=9):         
📄 Line 1079 (in_class=1, brace_depth=9):         // 🚀 【JavaScript行レベル二重アタック】パターン9: アロー関数プロパティ - prop: () => { (TypeScript成功パターン移植)
📄 Line 1080 (in_class=1, brace_depth=10):         std::regex arrow_property_pattern(R"(^\s*(\w+):\s*\([^)]*\)\s*=>\s*\{?)");
📄 Line 1081 (in_class=1, brace_depth=11):         if (std::regex_search(line, match, arrow_property_pattern)) {
📄 Line 1082 (in_class=1, brace_depth=12):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class JavaScriptPEGTLAnalyzer at line 1082
    📝 Line content: '            std::string prop_name = match[1].str();'
📄 Line 1083 (in_class=1, brace_depth=12):             if (!is_control_keyword(prop_name) && existing_functions.find(prop_name) == existing_functions.end()) {
📄 Line 1084 (in_class=1, brace_depth=13):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1084
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1085 (in_class=1, brace_depth=13):                 func_info.name = prop_name;
📄 Line 1086 (in_class=1, brace_depth=13):                 func_info.start_line = line_number;
📄 Line 1087 (in_class=1, brace_depth=13):                 func_info.is_arrow_function = true;
📄 Line 1088 (in_class=1, brace_depth=13):                 func_info.metadata["is_property_arrow"] = "true";
📄 Line 1089 (in_class=1, brace_depth=13):                 func_info.metadata["pattern_type"] = "arrow_property";
📄 Line 1090 (in_class=1, brace_depth=13):                 result.functions.push_back(func_info);
📄 Line 1091 (in_class=1, brace_depth=13):                 existing_functions.insert(prop_name);
📄 Line 1092 (in_class=1, brace_depth=13):                 // std::cerr << "[DEBUG] 🚀 Arrow property: " << prop_name << " at line " << line_number << std::endl;
📄 Line 1093 (in_class=1, brace_depth=13):             }
📄 Line 1094 (in_class=1, brace_depth=12):         }
📄 Line 1095 (in_class=1, brace_depth=11):         
📄 Line 1096 (in_class=1, brace_depth=11):         // 🎯 【JavaScript行レベル二重アタック】パターン10: 複雑なプロパティ構文 - prop: function() { (TypeScript成功パターン移植)
📄 Line 1097 (in_class=1, brace_depth=12):         std::regex complex_property_pattern(R"(^\s*(\w+):\s*function\s*\([^)]*\)\s*\{)");
📄 Line 1098 (in_class=1, brace_depth=13):         if (std::regex_search(line, match, complex_property_pattern)) {
📄 Line 1099 (in_class=1, brace_depth=14):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class JavaScriptPEGTLAnalyzer at line 1099
    📝 Line content: '            std::string prop_name = match[1].str();'
📄 Line 1100 (in_class=1, brace_depth=14):             if (!is_control_keyword(prop_name) && existing_functions.find(prop_name) == existing_functions.end()) {
📄 Line 1101 (in_class=1, brace_depth=15):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1101
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1102 (in_class=1, brace_depth=15):                 func_info.name = prop_name;
📄 Line 1103 (in_class=1, brace_depth=15):                 func_info.start_line = line_number;
📄 Line 1104 (in_class=1, brace_depth=15):                 func_info.metadata["is_property_function"] = "true";
📄 Line 1105 (in_class=1, brace_depth=15):                 func_info.metadata["pattern_type"] = "property_function";
📄 Line 1106 (in_class=1, brace_depth=15):                 result.functions.push_back(func_info);
📄 Line 1107 (in_class=1, brace_depth=15):                 existing_functions.insert(prop_name);
📄 Line 1108 (in_class=1, brace_depth=15):                 // std::cerr << "[DEBUG] 🎯 Property function: " << prop_name << " at line " << line_number << std::endl;
📄 Line 1109 (in_class=1, brace_depth=15):             }
📄 Line 1110 (in_class=1, brace_depth=14):         }
📄 Line 1111 (in_class=1, brace_depth=13):         
📄 Line 1112 (in_class=1, brace_depth=13):         // パターン7: async class method - async methodName(params) { 🔥 NEW!
📄 Line 1113 (in_class=1, brace_depth=14):         std::regex async_class_method_pattern(R"(^\s*async\s+(\w+)\s*\(\s*[^)]*\s*\)\s*\{)");
📄 Line 1114 (in_class=1, brace_depth=15):         if (std::regex_search(line, match, async_class_method_pattern)) {
📄 Line 1115 (in_class=1, brace_depth=16):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class JavaScriptPEGTLAnalyzer at line 1115
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 1116 (in_class=1, brace_depth=16):             // constructorは関数として扱わない
📄 Line 1117 (in_class=1, brace_depth=16):             if (method_name != "constructor" && existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 1118 (in_class=1, brace_depth=17):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1118
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1119 (in_class=1, brace_depth=17):                 func_info.name = method_name;
📄 Line 1120 (in_class=1, brace_depth=17):                 func_info.start_line = line_number;
📄 Line 1121 (in_class=1, brace_depth=17):                 func_info.is_async = true;
📄 Line 1122 (in_class=1, brace_depth=17):                 func_info.metadata["is_class_method"] = "true";
📄 Line 1123 (in_class=1, brace_depth=17):                 result.functions.push_back(func_info);
📄 Line 1124 (in_class=1, brace_depth=17):                 existing_functions.insert(method_name);
📄 Line 1125 (in_class=1, brace_depth=17):                 // std::cerr << "[DEBUG] Fallback found async class method: " << method_name << " at line " << line_number << std::endl;
📄 Line 1126 (in_class=1, brace_depth=17):             }
📄 Line 1127 (in_class=1, brace_depth=16):         }
📄 Line 1128 (in_class=1, brace_depth=15):     }
📄 Line 1129 (in_class=1, brace_depth=14):     
📄 Line 1130 (in_class=1, brace_depth=14):     // 🚀 【JavaScript専用】無限ネスト掘削アタック（コールバック地獄対応版）
📄 Line 1131 (in_class=1, brace_depth=14):     void extract_nested_functions_recursively(AnalysisResult& result, const std::vector<std::string>& all_lines, 
📄 Line 1132 (in_class=1, brace_depth=14):                                                std::set<std::string>& existing_functions) {
📄 Line 1133 (in_class=1, brace_depth=15):         
📄 Line 1134 (in_class=1, brace_depth=15):         // 📈 層別プロファイリング用
📄 Line 1135 (in_class=1, brace_depth=15):         std::vector<std::chrono::milliseconds> layer_times;
🎯 Found member variable: layer_times in class JavaScriptPEGTLAnalyzer at line 1135
    📝 Line content: '        std::vector<std::chrono::milliseconds> layer_times;'
📄 Line 1136 (in_class=1, brace_depth=15):         std::vector<size_t> layer_ranges;
🎯 Found member variable: layer_ranges in class JavaScriptPEGTLAnalyzer at line 1136
    📝 Line content: '        std::vector<size_t> layer_ranges;'
📄 Line 1137 (in_class=1, brace_depth=15):         std::vector<size_t> layer_detections;
🎯 Found member variable: layer_detections in class JavaScriptPEGTLAnalyzer at line 1137
    📝 Line content: '        std::vector<size_t> layer_detections;'
📄 Line 1138 (in_class=1, brace_depth=15):         std::vector<size_t> layer_lines;
🎯 Found member variable: layer_lines in class JavaScriptPEGTLAnalyzer at line 1138
    📝 Line content: '        std::vector<size_t> layer_lines;'
📄 Line 1139 (in_class=1, brace_depth=15):         
📄 Line 1140 (in_class=1, brace_depth=15):         // 初期範囲設定：全体を1つの範囲として開始
📄 Line 1141 (in_class=1, brace_depth=15):         std::vector<FunctionRange> current_ranges = {{1, all_lines.size(), 0}};
🎯 Found member variable: current_ranges in class JavaScriptPEGTLAnalyzer at line 1141
    📝 Line content: '        std::vector<FunctionRange> current_ranges = {{1, all_lines.size(), 0}};'
📄 Line 1142 (in_class=1, brace_depth=15):         size_t total_processing_time = 0;
🎯 Found member variable: total_processing_time in class JavaScriptPEGTLAnalyzer at line 1142
    📝 Line content: '        size_t total_processing_time = 0;'
📄 Line 1143 (in_class=1, brace_depth=15):         size_t total_scanned_lines = 0;
🎯 Found member variable: total_scanned_lines in class JavaScriptPEGTLAnalyzer at line 1143
    📝 Line content: '        size_t total_scanned_lines = 0;'
📄 Line 1144 (in_class=1, brace_depth=15):         size_t round_count = 0;
🎯 Found member variable: round_count in class JavaScriptPEGTLAnalyzer at line 1144
    📝 Line content: '        size_t round_count = 0;'
📄 Line 1145 (in_class=1, brace_depth=15):         const size_t MAX_DEPTH = 5; // JavaScript特化：コールバック地獄でも5層まで
🎯 Found member variable: MAX_DEPTH in class JavaScriptPEGTLAnalyzer at line 1145
    📝 Line content: '        const size_t MAX_DEPTH = 5; // JavaScript特化：コールバック地獄でも5層まで'
📄 Line 1146 (in_class=1, brace_depth=15):         
📄 Line 1147 (in_class=1, brace_depth=15):         // 📊 ネスト掘削統計
📄 Line 1148 (in_class=1, brace_depth=15):         std::atomic<size_t> total_nested_found{0};
📄 Line 1149 (in_class=1, brace_depth=15):         
📄 Line 1150 (in_class=1, brace_depth=15):         while (!current_ranges.empty() && round_count < MAX_DEPTH) {
📄 Line 1151 (in_class=1, brace_depth=16):             round_count++;
📄 Line 1152 (in_class=1, brace_depth=16):             
📄 Line 1153 (in_class=1, brace_depth=16):             auto round_start = std::chrono::high_resolution_clock::now();
🎯 Found member variable: round_start in class JavaScriptPEGTLAnalyzer at line 1153
    📝 Line content: '            auto round_start = std::chrono::high_resolution_clock::now();'
📄 Line 1154 (in_class=1, brace_depth=16):             std::vector<FunctionRange> next_ranges;
🎯 Found member variable: next_ranges in class JavaScriptPEGTLAnalyzer at line 1154
    📝 Line content: '            std::vector<FunctionRange> next_ranges;'
📄 Line 1155 (in_class=1, brace_depth=16):             std::atomic<size_t> round_detections{0};
📄 Line 1156 (in_class=1, brace_depth=16):             size_t round_lines = 0;
🎯 Found member variable: round_lines in class JavaScriptPEGTLAnalyzer at line 1156
    📝 Line content: '            size_t round_lines = 0;'
📄 Line 1157 (in_class=1, brace_depth=16):             
📄 Line 1158 (in_class=1, brace_depth=16):             // スレッドセーフな範囲・出力管理
📄 Line 1159 (in_class=1, brace_depth=16):             std::mutex ranges_mutex;
🎯 Found member variable: ranges_mutex in class JavaScriptPEGTLAnalyzer at line 1159
    📝 Line content: '            std::mutex ranges_mutex;'
📄 Line 1160 (in_class=1, brace_depth=16):             std::mutex output_mutex;
🎯 Found member variable: output_mutex in class JavaScriptPEGTLAnalyzer at line 1160
    📝 Line content: '            std::mutex output_mutex;'
📄 Line 1161 (in_class=1, brace_depth=16):             
📄 Line 1162 (in_class=1, brace_depth=16):             std::cerr << "🎯 JavaScript第" << round_count << "回ネスト掘削攻撃開始！（検索範囲: " 
📄 Line 1163 (in_class=1, brace_depth=16):                       << current_ranges.size() << "個）" << std::endl;
📄 Line 1164 (in_class=1, brace_depth=16):             
📄 Line 1165 (in_class=1, brace_depth=16):             // 🔥 並列処理でコールバック地獄を高速攻略！
📄 Line 1166 (in_class=1, brace_depth=16):             std::for_each(std::execution::par_unseq,
📄 Line 1167 (in_class=1, brace_depth=16):                           current_ranges.begin(),
📄 Line 1168 (in_class=1, brace_depth=16):                           current_ranges.end(),
📄 Line 1169 (in_class=1, brace_depth=16):                           [&](const FunctionRange& range) {
📄 Line 1170 (in_class=1, brace_depth=17):                               
📄 Line 1171 (in_class=1, brace_depth=17):                 size_t range_lines = 0;
🎯 Found member variable: range_lines in class JavaScriptPEGTLAnalyzer at line 1171
    📝 Line content: '                size_t range_lines = 0;'
📄 Line 1172 (in_class=1, brace_depth=17):                               
📄 Line 1173 (in_class=1, brace_depth=17):                 for (size_t line_idx = range.start_line - 1; 
📄 Line 1174 (in_class=1, brace_depth=17):                      line_idx < std::min(range.end_line, all_lines.size()); line_idx++) {
📄 Line 1175 (in_class=1, brace_depth=18):                     
📄 Line 1176 (in_class=1, brace_depth=18):                     const std::string& line = all_lines[line_idx];
🎯 Found member variable: line in class JavaScriptPEGTLAnalyzer at line 1176
    📝 Line content: '                    const std::string& line = all_lines[line_idx];'
📄 Line 1177 (in_class=1, brace_depth=18):                     size_t current_line_number = line_idx + 1;
🎯 Found member variable: current_line_number in class JavaScriptPEGTLAnalyzer at line 1177
    📝 Line content: '                    size_t current_line_number = line_idx + 1;'
📄 Line 1178 (in_class=1, brace_depth=18):                     range_lines++;
📄 Line 1179 (in_class=1, brace_depth=18):                     
📄 Line 1180 (in_class=1, brace_depth=18):                     // 🎯 JavaScriptネスト関数パターン検出
📄 Line 1181 (in_class=1, brace_depth=18):                     std::vector<FunctionInfo> detected_functions = 
📄 Line 1182 (in_class=1, brace_depth=18):                         detect_javascript_nested_functions(line, current_line_number, existing_functions);
📄 Line 1183 (in_class=1, brace_depth=18):                     
📄 Line 1184 (in_class=1, brace_depth=18):                     if (!detected_functions.empty()) {
📄 Line 1185 (in_class=1, brace_depth=19):                         // 検出された関数を結果に追加
📄 Line 1186 (in_class=1, brace_depth=19):                         {
📄 Line 1187 (in_class=1, brace_depth=20):                             std::lock_guard<std::mutex> output_lock(output_mutex);
📄 Line 1188 (in_class=1, brace_depth=20):                             for (const auto& func : detected_functions) {
📄 Line 1189 (in_class=1, brace_depth=21):                                 result.functions.push_back(func);
📄 Line 1190 (in_class=1, brace_depth=21):                                 existing_functions.insert(func.name);
📄 Line 1191 (in_class=1, brace_depth=21):                                 round_detections++;
📄 Line 1192 (in_class=1, brace_depth=21):                                 total_nested_found++;
📄 Line 1193 (in_class=1, brace_depth=21):                                 
📄 Line 1194 (in_class=1, brace_depth=21):                                 std::cerr << "🎯 第" << round_count << "回でネスト" 
📄 Line 1195 (in_class=1, brace_depth=21):                                           << (func.is_arrow_function ? "アロー" : "") 
📄 Line 1196 (in_class=1, brace_depth=21):                                           << "関数発見: " << func.name << " (行:" << func.start_line << ")" << std::endl;
📄 Line 1197 (in_class=1, brace_depth=21):                                 
📄 Line 1198 (in_class=1, brace_depth=21):                                 // 次回検索範囲の追加（コールバック地獄対応）
📄 Line 1199 (in_class=1, brace_depth=21):                                 if (range.indent_level < MAX_DEPTH - 1) {
📄 Line 1200 (in_class=1, brace_depth=22):                                     size_t next_start = func.start_line + 1;
🎯 Found member variable: next_start in class JavaScriptPEGTLAnalyzer at line 1200
    📝 Line content: '                                    size_t next_start = func.start_line + 1;'
📄 Line 1201 (in_class=1, brace_depth=22):                                     size_t next_end = std::min(static_cast<size_t>(func.start_line + 50), all_lines.size()); // JavaScript関数は50行程度の範囲
🎯 Found member variable: next_end in class JavaScriptPEGTLAnalyzer at line 1201
    📝 Line content: '                                    size_t next_end = std::min(static_cast<size_t>(func.start_line + 50), all_lines.size()); // JavaScript関数は50行程度の範囲'
📄 Line 1202 (in_class=1, brace_depth=22):                                     
📄 Line 1203 (in_class=1, brace_depth=22):                                     if (next_start < next_end) {
📄 Line 1204 (in_class=1, brace_depth=23):                                         std::lock_guard<std::mutex> ranges_lock(ranges_mutex);
📄 Line 1205 (in_class=1, brace_depth=23):                                         next_ranges.push_back({next_start, next_end, range.indent_level + 1});
📄 Line 1206 (in_class=1, brace_depth=23):                                         std::cerr << "  → 次回検索範囲追加: 行" << next_start << "-" << next_end 
📄 Line 1207 (in_class=1, brace_depth=23):                                                   << " (深さ:" << (range.indent_level + 1) << ")" << std::endl;
📄 Line 1208 (in_class=1, brace_depth=23):                                     }
📄 Line 1209 (in_class=1, brace_depth=22):                                 }
📄 Line 1210 (in_class=1, brace_depth=21):                             }
📄 Line 1211 (in_class=1, brace_depth=20):                         }
📄 Line 1212 (in_class=1, brace_depth=19):                     }
📄 Line 1213 (in_class=1, brace_depth=18):                 }
📄 Line 1214 (in_class=1, brace_depth=17):                 
📄 Line 1215 (in_class=1, brace_depth=17):                 // 🔢 行数統計の更新
📄 Line 1216 (in_class=1, brace_depth=17):                 {
📄 Line 1217 (in_class=1, brace_depth=18):                     std::lock_guard<std::mutex> output_lock(output_mutex);
📄 Line 1218 (in_class=1, brace_depth=18):                     round_lines += range_lines;
📄 Line 1219 (in_class=1, brace_depth=18):                 }
📄 Line 1220 (in_class=1, brace_depth=17):             });
📄 Line 1221 (in_class=1, brace_depth=16):             
📄 Line 1222 (in_class=1, brace_depth=16):             auto round_end = std::chrono::high_resolution_clock::now();
🎯 Found member variable: round_end in class JavaScriptPEGTLAnalyzer at line 1222
    📝 Line content: '            auto round_end = std::chrono::high_resolution_clock::now();'
📄 Line 1223 (in_class=1, brace_depth=16):             auto round_time = std::chrono::duration_cast<std::chrono::milliseconds>(round_end - round_start);
🎯 Found member variable: round_time in class JavaScriptPEGTLAnalyzer at line 1223
    📝 Line content: '            auto round_time = std::chrono::duration_cast<std::chrono::milliseconds>(round_end - round_start);'
📄 Line 1224 (in_class=1, brace_depth=16):             
📄 Line 1225 (in_class=1, brace_depth=16):             // 📊 層別統計記録
📄 Line 1226 (in_class=1, brace_depth=16):             layer_times.push_back(round_time);
📄 Line 1227 (in_class=1, brace_depth=16):             layer_ranges.push_back(current_ranges.size());
📄 Line 1228 (in_class=1, brace_depth=16):             layer_detections.push_back(round_detections);
📄 Line 1229 (in_class=1, brace_depth=16):             layer_lines.push_back(round_lines);
📄 Line 1230 (in_class=1, brace_depth=16):             
📄 Line 1231 (in_class=1, brace_depth=16):             total_processing_time += round_time.count();
📄 Line 1232 (in_class=1, brace_depth=16):             total_scanned_lines += round_lines;
📄 Line 1233 (in_class=1, brace_depth=16):             
📄 Line 1234 (in_class=1, brace_depth=16):             std::cerr << "🎯 JavaScript第" << round_count << "回攻撃完了！新規検出: " << round_detections 
📄 Line 1235 (in_class=1, brace_depth=16):                       << "個 (処理時間: " << round_time.count() << "ms, 処理行数: " << round_lines << "行)" << std::endl;
📄 Line 1236 (in_class=1, brace_depth=16):             
📄 Line 1237 (in_class=1, brace_depth=16):             current_ranges = std::move(next_ranges);
📄 Line 1238 (in_class=1, brace_depth=16):             
📄 Line 1239 (in_class=1, brace_depth=16):             if (round_detections == 0) {
📄 Line 1240 (in_class=1, brace_depth=17):                 std::cerr << "🎉 JavaScript無限ネスト掘削アタック完了！検索範囲が空になりました" << std::endl;
📄 Line 1241 (in_class=1, brace_depth=17):                 break;
📄 Line 1242 (in_class=1, brace_depth=17):             }
📄 Line 1243 (in_class=1, brace_depth=16):         }
📄 Line 1244 (in_class=1, brace_depth=15):         
📄 Line 1245 (in_class=1, brace_depth=15):         std::cerr << "⏱️  JavaScript総処理時間: " << total_processing_time << "ms, 総スキャン行数: " 
📄 Line 1246 (in_class=1, brace_depth=15):                   << total_scanned_lines << "行 (ラウンド数: " << round_count << "回)" << std::endl;
📄 Line 1247 (in_class=1, brace_depth=15):         
📄 Line 1248 (in_class=1, brace_depth=15):         // 📊 詳細プロファイリング出力
📄 Line 1249 (in_class=1, brace_depth=15):         std::cerr << "\n📊 === JavaScript層ごとの詳細プロファイリング ===" << std::endl;
📄 Line 1250 (in_class=1, brace_depth=15):         for (size_t i = 0; i < layer_times.size(); i++) {
📄 Line 1251 (in_class=1, brace_depth=16):             double ms_per_line = layer_lines[i] > 0 ? static_cast<double>(layer_times[i].count()) / layer_lines[i] : 0.0;
🎯 Found member variable: ms_per_line in class JavaScriptPEGTLAnalyzer at line 1251
    📝 Line content: '            double ms_per_line = layer_lines[i] > 0 ? static_cast<double>(layer_times[i].count()) / layer_lines[i] : 0.0;'
📄 Line 1252 (in_class=1, brace_depth=16):             std::cerr << "📈 JavaScript第" << (i+1) << "層: " << layer_times[i].count() << "ms, " 
📄 Line 1253 (in_class=1, brace_depth=16):                       << layer_ranges[i] << "範囲, " << layer_detections[i] << "個検出, " 
📄 Line 1254 (in_class=1, brace_depth=16):                       << layer_lines[i] << "行処理 (1行あたり: " 
📄 Line 1255 (in_class=1, brace_depth=16):                       << std::fixed << std::setprecision(3) << ms_per_line << "ms)" << std::endl;
📄 Line 1256 (in_class=1, brace_depth=16):         }
📄 Line 1257 (in_class=1, brace_depth=15):         
📄 Line 1258 (in_class=1, brace_depth=15):         // 📊 累積処理時間
📄 Line 1259 (in_class=1, brace_depth=15):         std::cerr << "\n📊 === JavaScript累積処理時間 ===" << std::endl;
📄 Line 1260 (in_class=1, brace_depth=15):         size_t cumulative_time = 0;
🎯 Found member variable: cumulative_time in class JavaScriptPEGTLAnalyzer at line 1260
    📝 Line content: '        size_t cumulative_time = 0;'
📄 Line 1261 (in_class=1, brace_depth=15):         for (size_t i = 0; i < layer_times.size(); i++) {
📄 Line 1262 (in_class=1, brace_depth=16):             cumulative_time += layer_times[i].count();
📄 Line 1263 (in_class=1, brace_depth=16):             std::cerr << "🏃 JavaScript第1層〜第" << (i+1) << "層までの累積: " << cumulative_time << "ms" << std::endl;
📄 Line 1264 (in_class=1, brace_depth=16):         }
📄 Line 1265 (in_class=1, brace_depth=15):         std::cerr << "===================================" << std::endl;
📄 Line 1266 (in_class=1, brace_depth=15):     }
📄 Line 1267 (in_class=1, brace_depth=14):     
📄 Line 1268 (in_class=1, brace_depth=14):     // 🎯 JavaScriptネスト関数検出（コールバック地獄専用）
📄 Line 1269 (in_class=1, brace_depth=14):     std::vector<FunctionInfo> detect_javascript_nested_functions(const std::string& line, size_t line_number, 
📄 Line 1270 (in_class=1, brace_depth=14):                                                                  std::set<std::string>& existing_functions) {
📄 Line 1271 (in_class=1, brace_depth=15):         std::vector<FunctionInfo> detected_functions;
🎯 Found member variable: detected_functions in class JavaScriptPEGTLAnalyzer at line 1271
    📝 Line content: '        std::vector<FunctionInfo> detected_functions;'
📄 Line 1272 (in_class=1, brace_depth=15):         std::smatch match;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1272
    📝 Line content: '        std::smatch match;'
📄 Line 1273 (in_class=1, brace_depth=15):         
📄 Line 1274 (in_class=1, brace_depth=15):         // 制御構造フィルタリング
📄 Line 1275 (in_class=1, brace_depth=15):         static const std::set<std::string> control_keywords = {
📄 Line 1276 (in_class=1, brace_depth=16):             "if", "else", "for", "while", "do", "switch", "case", "catch", 
📄 Line 1277 (in_class=1, brace_depth=16):             "try", "finally", "return", "break", "continue", "throw", 
📄 Line 1278 (in_class=1, brace_depth=16):             "typeof", "instanceof", "new", "delete", "var", "let", "const"
📄 Line 1279 (in_class=1, brace_depth=16):         };
📄 Line 1280 (in_class=1, brace_depth=15):         
📄 Line 1281 (in_class=1, brace_depth=15):         auto is_control_keyword = [&](const std::string& name) {
📄 Line 1282 (in_class=1, brace_depth=16):             return control_keywords.find(name) != control_keywords.end();
📄 Line 1283 (in_class=1, brace_depth=16):         };
📄 Line 1284 (in_class=1, brace_depth=15):         
📄 Line 1285 (in_class=1, brace_depth=15):         // 🎯 パターン1: コールバック内関数 - function(
📄 Line 1286 (in_class=1, brace_depth=15):         std::regex nested_function_pattern(R"(function\s+(\w+)\s*\()");
📄 Line 1287 (in_class=1, brace_depth=15):         auto func_begin = std::sregex_iterator(line.begin(), line.end(), nested_function_pattern);
🎯 Found member variable: func_begin in class JavaScriptPEGTLAnalyzer at line 1287
    📝 Line content: '        auto func_begin = std::sregex_iterator(line.begin(), line.end(), nested_function_pattern);'
📄 Line 1288 (in_class=1, brace_depth=15):         auto func_end = std::sregex_iterator();
🎯 Found member variable: func_end in class JavaScriptPEGTLAnalyzer at line 1288
    📝 Line content: '        auto func_end = std::sregex_iterator();'
📄 Line 1289 (in_class=1, brace_depth=15):         
📄 Line 1290 (in_class=1, brace_depth=15):         for (std::sregex_iterator i = func_begin; i != func_end; ++i) {
📄 Line 1291 (in_class=1, brace_depth=16):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1291
    📝 Line content: '            std::smatch match = *i;'
📄 Line 1292 (in_class=1, brace_depth=16):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 1292
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 1293 (in_class=1, brace_depth=16):             
📄 Line 1294 (in_class=1, brace_depth=16):             if (!is_control_keyword(func_name) && existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 1295 (in_class=1, brace_depth=17):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1295
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1296 (in_class=1, brace_depth=17):                 func_info.name = func_name;
📄 Line 1297 (in_class=1, brace_depth=17):                 func_info.start_line = line_number;
📄 Line 1298 (in_class=1, brace_depth=17):                 func_info.metadata["nested_type"] = "callback_function";
📄 Line 1299 (in_class=1, brace_depth=17):                 detected_functions.push_back(func_info);
📄 Line 1300 (in_class=1, brace_depth=17):             }
📄 Line 1301 (in_class=1, brace_depth=16):         }
📄 Line 1302 (in_class=1, brace_depth=15):         
📄 Line 1303 (in_class=1, brace_depth=15):         // 🎯 パターン2: アロー関数変数 - const name = (
📄 Line 1304 (in_class=1, brace_depth=15):         std::regex nested_arrow_pattern(R"((?:const|let|var)\s+(\w+)\s*=\s*\([^)]*\)\s*=>)");
📄 Line 1305 (in_class=1, brace_depth=15):         auto arrow_begin = std::sregex_iterator(line.begin(), line.end(), nested_arrow_pattern);
🎯 Found member variable: arrow_begin in class JavaScriptPEGTLAnalyzer at line 1305
    📝 Line content: '        auto arrow_begin = std::sregex_iterator(line.begin(), line.end(), nested_arrow_pattern);'
📄 Line 1306 (in_class=1, brace_depth=15):         auto arrow_end = std::sregex_iterator();
🎯 Found member variable: arrow_end in class JavaScriptPEGTLAnalyzer at line 1306
    📝 Line content: '        auto arrow_end = std::sregex_iterator();'
📄 Line 1307 (in_class=1, brace_depth=15):         
📄 Line 1308 (in_class=1, brace_depth=15):         for (std::sregex_iterator i = arrow_begin; i != arrow_end; ++i) {
📄 Line 1309 (in_class=1, brace_depth=16):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1309
    📝 Line content: '            std::smatch match = *i;'
📄 Line 1310 (in_class=1, brace_depth=16):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 1310
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 1311 (in_class=1, brace_depth=16):             
📄 Line 1312 (in_class=1, brace_depth=16):             if (!is_control_keyword(func_name) && existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 1313 (in_class=1, brace_depth=17):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1313
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1314 (in_class=1, brace_depth=17):                 func_info.name = func_name;
📄 Line 1315 (in_class=1, brace_depth=17):                 func_info.start_line = line_number;
📄 Line 1316 (in_class=1, brace_depth=17):                 func_info.is_arrow_function = true;
📄 Line 1317 (in_class=1, brace_depth=17):                 func_info.metadata["nested_type"] = "arrow_callback";
📄 Line 1318 (in_class=1, brace_depth=17):                 detected_functions.push_back(func_info);
📄 Line 1319 (in_class=1, brace_depth=17):             }
📄 Line 1320 (in_class=1, brace_depth=16):         }
📄 Line 1321 (in_class=1, brace_depth=15):         
📄 Line 1322 (in_class=1, brace_depth=15):         // 🎯 パターン3: オブジェクトメソッド - methodName: function(
📄 Line 1323 (in_class=1, brace_depth=15):         std::regex method_pattern(R"((\w+):\s*function\s*\()");
📄 Line 1324 (in_class=1, brace_depth=15):         auto method_begin = std::sregex_iterator(line.begin(), line.end(), method_pattern);
🎯 Found member variable: method_begin in class JavaScriptPEGTLAnalyzer at line 1324
    📝 Line content: '        auto method_begin = std::sregex_iterator(line.begin(), line.end(), method_pattern);'
📄 Line 1325 (in_class=1, brace_depth=15):         auto method_end = std::sregex_iterator();
🎯 Found member variable: method_end in class JavaScriptPEGTLAnalyzer at line 1325
    📝 Line content: '        auto method_end = std::sregex_iterator();'
📄 Line 1326 (in_class=1, brace_depth=15):         
📄 Line 1327 (in_class=1, brace_depth=15):         for (std::sregex_iterator i = method_begin; i != method_end; ++i) {
📄 Line 1328 (in_class=1, brace_depth=16):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1328
    📝 Line content: '            std::smatch match = *i;'
📄 Line 1329 (in_class=1, brace_depth=16):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class JavaScriptPEGTLAnalyzer at line 1329
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 1330 (in_class=1, brace_depth=16):             
📄 Line 1331 (in_class=1, brace_depth=16):             if (!is_control_keyword(method_name) && existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 1332 (in_class=1, brace_depth=17):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1332
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1333 (in_class=1, brace_depth=17):                 func_info.name = method_name;
📄 Line 1334 (in_class=1, brace_depth=17):                 func_info.start_line = line_number;
📄 Line 1335 (in_class=1, brace_depth=17):                 func_info.metadata["nested_type"] = "object_method";
📄 Line 1336 (in_class=1, brace_depth=17):                 detected_functions.push_back(func_info);
📄 Line 1337 (in_class=1, brace_depth=17):             }
📄 Line 1338 (in_class=1, brace_depth=16):         }
📄 Line 1339 (in_class=1, brace_depth=15):         
📄 Line 1340 (in_class=1, brace_depth=15):         // 🎯 パターン4: 関数式 - const name = function
📄 Line 1341 (in_class=1, brace_depth=15):         std::regex function_expression_pattern(R"((?:const|let|var)\s+(\w+)\s*=\s*function\s*\()");
📄 Line 1342 (in_class=1, brace_depth=15):         if (std::regex_search(line, match, function_expression_pattern)) {
📄 Line 1343 (in_class=1, brace_depth=16):             std::string func_name = match[1].str();
🎯 Found member variable: func_name in class JavaScriptPEGTLAnalyzer at line 1343
    📝 Line content: '            std::string func_name = match[1].str();'
📄 Line 1344 (in_class=1, brace_depth=16):             
📄 Line 1345 (in_class=1, brace_depth=16):             if (!is_control_keyword(func_name) && existing_functions.find(func_name) == existing_functions.end()) {
📄 Line 1346 (in_class=1, brace_depth=17):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1346
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1347 (in_class=1, brace_depth=17):                 func_info.name = func_name;
📄 Line 1348 (in_class=1, brace_depth=17):                 func_info.start_line = line_number;
📄 Line 1349 (in_class=1, brace_depth=17):                 func_info.metadata["nested_type"] = "function_expression";
📄 Line 1350 (in_class=1, brace_depth=17):                 detected_functions.push_back(func_info);
📄 Line 1351 (in_class=1, brace_depth=17):             }
📄 Line 1352 (in_class=1, brace_depth=16):         }
📄 Line 1353 (in_class=1, brace_depth=15):         
📄 Line 1354 (in_class=1, brace_depth=15):         // 🔥 【JavaScript無限ネスト掘削アタック強化】パターン5: ES2015ネストメソッドショートハンド - method() { (TypeScript成功パターン移植)
📄 Line 1355 (in_class=1, brace_depth=16):         std::regex nested_es2015_method_pattern(R"((\w+)\s*\(\s*[^)]*\s*\)\s*\{)");
📄 Line 1356 (in_class=1, brace_depth=17):         auto es2015_begin = std::sregex_iterator(line.begin(), line.end(), nested_es2015_method_pattern);
🎯 Found member variable: es2015_begin in class JavaScriptPEGTLAnalyzer at line 1356
    📝 Line content: '        auto es2015_begin = std::sregex_iterator(line.begin(), line.end(), nested_es2015_method_pattern);'
📄 Line 1357 (in_class=1, brace_depth=17):         auto es2015_end = std::sregex_iterator();
🎯 Found member variable: es2015_end in class JavaScriptPEGTLAnalyzer at line 1357
    📝 Line content: '        auto es2015_end = std::sregex_iterator();'
📄 Line 1358 (in_class=1, brace_depth=17):         
📄 Line 1359 (in_class=1, brace_depth=17):         for (std::sregex_iterator i = es2015_begin; i != es2015_end; ++i) {
📄 Line 1360 (in_class=1, brace_depth=18):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1360
    📝 Line content: '            std::smatch match = *i;'
📄 Line 1361 (in_class=1, brace_depth=18):             std::string method_name = match[1].str();
🎯 Found member variable: method_name in class JavaScriptPEGTLAnalyzer at line 1361
    📝 Line content: '            std::string method_name = match[1].str();'
📄 Line 1362 (in_class=1, brace_depth=18):             
📄 Line 1363 (in_class=1, brace_depth=18):             if (method_name != "constructor" && method_name != "get" && method_name != "set" && 
📄 Line 1364 (in_class=1, brace_depth=18):                 !is_control_keyword(method_name) && existing_functions.find(method_name) == existing_functions.end()) {
📄 Line 1365 (in_class=1, brace_depth=19):                 // ネスト内のメソッドショートハンド
📄 Line 1366 (in_class=1, brace_depth=19):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1366
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1367 (in_class=1, brace_depth=19):                 func_info.name = method_name;
📄 Line 1368 (in_class=1, brace_depth=19):                 func_info.start_line = line_number;
📄 Line 1369 (in_class=1, brace_depth=19):                 func_info.metadata["nested_type"] = "es2015_method_shorthand";
📄 Line 1370 (in_class=1, brace_depth=19):                 func_info.metadata["pattern_source"] = "nested_detection";
📄 Line 1371 (in_class=1, brace_depth=19):                 detected_functions.push_back(func_info);
📄 Line 1372 (in_class=1, brace_depth=19):             }
📄 Line 1373 (in_class=1, brace_depth=18):         }
📄 Line 1374 (in_class=1, brace_depth=17):         
📄 Line 1375 (in_class=1, brace_depth=17):         // 🚀 【JavaScript無限ネスト掘削アタック強化】パターン6: ネストアロー関数プロパティ - prop: () => { (TypeScript成功パターン移植)
📄 Line 1376 (in_class=1, brace_depth=18):         std::regex nested_arrow_property_pattern(R"((\w+):\s*\([^)]*\)\s*=>\s*\{?)");
📄 Line 1377 (in_class=1, brace_depth=19):         auto arrow_prop_begin = std::sregex_iterator(line.begin(), line.end(), nested_arrow_property_pattern);
🎯 Found member variable: arrow_prop_begin in class JavaScriptPEGTLAnalyzer at line 1377
    📝 Line content: '        auto arrow_prop_begin = std::sregex_iterator(line.begin(), line.end(), nested_arrow_property_pattern);'
📄 Line 1378 (in_class=1, brace_depth=19):         auto arrow_prop_end = std::sregex_iterator();
🎯 Found member variable: arrow_prop_end in class JavaScriptPEGTLAnalyzer at line 1378
    📝 Line content: '        auto arrow_prop_end = std::sregex_iterator();'
📄 Line 1379 (in_class=1, brace_depth=19):         
📄 Line 1380 (in_class=1, brace_depth=19):         for (std::sregex_iterator i = arrow_prop_begin; i != arrow_prop_end; ++i) {
📄 Line 1381 (in_class=1, brace_depth=20):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1381
    📝 Line content: '            std::smatch match = *i;'
📄 Line 1382 (in_class=1, brace_depth=20):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class JavaScriptPEGTLAnalyzer at line 1382
    📝 Line content: '            std::string prop_name = match[1].str();'
📄 Line 1383 (in_class=1, brace_depth=20):             
📄 Line 1384 (in_class=1, brace_depth=20):             if (!is_control_keyword(prop_name) && existing_functions.find(prop_name) == existing_functions.end()) {
📄 Line 1385 (in_class=1, brace_depth=21):                 FunctionInfo func_info;
🎯 Found member variable: func_info in class JavaScriptPEGTLAnalyzer at line 1385
    📝 Line content: '                FunctionInfo func_info;'
📄 Line 1386 (in_class=1, brace_depth=21):                 func_info.name = prop_name;
📄 Line 1387 (in_class=1, brace_depth=21):                 func_info.start_line = line_number;
📄 Line 1388 (in_class=1, brace_depth=21):                 func_info.is_arrow_function = true;
📄 Line 1389 (in_class=1, brace_depth=21):                 func_info.metadata["nested_type"] = "arrow_property_nested";
📄 Line 1390 (in_class=1, brace_depth=21):                 func_info.metadata["pattern_source"] = "nested_detection";
📄 Line 1391 (in_class=1, brace_depth=21):                 detected_functions.push_back(func_info);
📄 Line 1392 (in_class=1, brace_depth=21):             }
📄 Line 1393 (in_class=1, brace_depth=20):         }
📄 Line 1394 (in_class=1, brace_depth=19):         
📄 Line 1395 (in_class=1, brace_depth=19):         // 🎯 【JavaScript無限ネスト掘削アタック強化】パターン7: 複雑ネストプロパティ関数 - prop: function() { (TypeScript成功パターン移植)
📄 Line 1396 (in_class=1, brace_depth=20):         std::regex nested_complex_property_pattern(R"((\w+):\s*function\s*\([^)]*\)\s*\{)");
📄 Line 1397 (in_class=1, brace_depth=21):         auto complex_prop_begin = std::sregex_iterator(line.begin(), line.end(), nested_complex_property_pattern);
🎯 Found member variable: complex_prop_begin in class JavaScriptPEGTLAnalyzer at line 1397
    📝 Line content: '        auto complex_prop_begin = std::sregex_iterator(line.begin(), line.end(), nested_complex_property_pattern);'
📄 Line 1398 (in_class=1, brace_depth=21):         auto complex_prop_end = std::sregex_iterator();
🎯 Found member variable: complex_prop_end in class JavaScriptPEGTLAnalyzer at line 1398
    📝 Line content: '        auto complex_prop_end = std::sregex_iterator();'
📄 Line 1399 (in_class=1, brace_depth=21):         
📄 Line 1400 (in_class=1, brace_depth=21):         for (std::sregex_iterator i = complex_prop_begin; i != complex_prop_end; ++i) {
📄 Line 1401 (in_class=1, brace_depth=22):             std::smatch match = *i;
🎯 Found member variable: match in class JavaScriptPEGTLAnalyzer at line 1401
    📝 Line content: '            std::smatch match = *i;'
📄 Line 1402 (in_class=1, brace_depth=22):             std::string prop_name = match[1].str();
🎯 Found member variable: prop_name in class JavaScriptPEGTLAnalyzer at line 1402
    📝 Line content: '            std::string prop_name = match[1].str();'
📍 Reached end_line 1402 for class JavaScriptPEGTLAnalyzer
🔍 Processing class: 'struct:FunctionRange'
📦 Struct detected, clean name: 'FunctionRange'
🎯 Found correct struct 'FunctionRange' at line 1418
✅ Corrected start_line for 'struct:FunctionRange': 1418
🔍 Scanning lines 1418-1473 for class 'FunctionRange'
🎯 Class start detected at line 1418:     struct FunctionRange {
📄 Line 1419 (in_class=1, brace_depth=1):         size_t start_line;
🎯 Found member variable: start_line in class FunctionRange at line 1419
    📝 Line content: '        size_t start_line;'
📄 Line 1420 (in_class=1, brace_depth=1):         size_t end_line;
🎯 Found member variable: end_line in class FunctionRange at line 1420
    📝 Line content: '        size_t end_line;'
📄 Line 1421 (in_class=1, brace_depth=1):         size_t indent_level;
🎯 Found member variable: indent_level in class FunctionRange at line 1421
    📝 Line content: '        size_t indent_level;'
📄 Line 1422 (in_class=1, brace_depth=1):     };
🔍 Before update_statistics: classes=6, functions=36
🔍 After update_statistics: stats.class_count=6, stats.function_count=36
[23:18:37.669] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/javascript/javascript_pegtl_analyzer.hpp
🔥 Final return: result.stats.class_count=6, result.stats.function_count=36
[23:18:37.669] [INFO ] [CppAnalyzer] Starting C++ PEGTL analysis of src/analyzers/unity/unity_analyzer.cpp (824 bytes)
🔍 Detected class: 'CPP_PEGTL_ANALYZER_CALLED'
🔍 Debug: complexity=5, detected_classes=1, actual_classes=0, detected_functions=0
🔍 Debug: has_class=0, has_struct=0, has_namespace=1
📊 Trigger reason: C++ patterns found but no classes detected
🔥 C++ Hybrid Strategy TRIGGERED!
[23:18:37.669] [INFO ] [CppAnalyzer] Hybrid strategy triggered - applying line-based fallback
📊 C++解析開始: 19行検出
🚀 通常モード: 全機能有効（C++最高精度）
✅ C++ハイブリッド戦略完了: 19行処理 (14ms)

📊 処理戦略: 通常モード（全機能有効）
✅ C++ Line-based analysis completed. Classes: 2, Functions: 0
🔍 Debug: Classes before=1, after=2, Functions before=0, after=0
🔍 Processing class: 'CPP_PEGTL_ANALYZER_CALLED'
❌ Could not find class 'CPP_PEGTL_ANALYZER_CALLED' in original content
🔍 Scanning lines 1-7 for class 'CPP_PEGTL_ANALYZER_CALLED'
🎯 Class start detected at line 1: //=============================================================================
📄 Line 2 (in_class=1, brace_depth=0): // 🎮 Unity Analyzer 実装 - コンポジション設計版
🔍 Processing class: 'namespace:nekocode'
⏭️  Skipping namespace: namespace:nekocode
🔍 Before update_statistics: classes=2, functions=0
🔍 After update_statistics: stats.class_count=2, stats.function_count=0
[23:18:37.685] [INFO ] [CppAnalyzer] C++ PEGTL analysis completed successfully for src/analyzers/unity/unity_analyzer.cpp
🔥 Final return: result.stats.class_count=2, result.stats.function_count=0
🚀 Parallel analysis completed: 12 files in 6345ms with --io-threads=4
{
  "analysis_type": "directory",
  "directory_path": "src/analyzers/",
  "summary": {
    "total_classes": 77,
    "total_functions": 147,
    "total_lines": 7098
  },
  "total_files": 12
}
